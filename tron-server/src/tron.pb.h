// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tron.proto

#ifndef PROTOBUF_tron_2eproto__INCLUDED
#define PROTOBUF_tron_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3005001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace protobuf_tron_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[10];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
void InitDefaultsAccountCommandImpl();
void InitDefaultsAccountCommand();
void InitDefaultsAccountResponseImpl();
void InitDefaultsAccountResponse();
void InitDefaultsRoomCommandImpl();
void InitDefaultsRoomCommand();
void InitDefaultsRoomResponse_RoomInfoImpl();
void InitDefaultsRoomResponse_RoomInfo();
void InitDefaultsRoomResponseImpl();
void InitDefaultsRoomResponse();
void InitDefaultsGameCommandImpl();
void InitDefaultsGameCommand();
void InitDefaultsGameResponse_GameSetImpl();
void InitDefaultsGameResponse_GameSet();
void InitDefaultsGameResponseImpl();
void InitDefaultsGameResponse();
void InitDefaultsCommandImpl();
void InitDefaultsCommand();
void InitDefaultsResponseImpl();
void InitDefaultsResponse();
inline void InitDefaults() {
  InitDefaultsAccountCommand();
  InitDefaultsAccountResponse();
  InitDefaultsRoomCommand();
  InitDefaultsRoomResponse_RoomInfo();
  InitDefaultsRoomResponse();
  InitDefaultsGameCommand();
  InitDefaultsGameResponse_GameSet();
  InitDefaultsGameResponse();
  InitDefaultsCommand();
  InitDefaultsResponse();
}
}  // namespace protobuf_tron_2eproto
namespace tronol {
namespace protobuf {
class AccountCommand;
class AccountCommandDefaultTypeInternal;
extern AccountCommandDefaultTypeInternal _AccountCommand_default_instance_;
class AccountResponse;
class AccountResponseDefaultTypeInternal;
extern AccountResponseDefaultTypeInternal _AccountResponse_default_instance_;
class Command;
class CommandDefaultTypeInternal;
extern CommandDefaultTypeInternal _Command_default_instance_;
class GameCommand;
class GameCommandDefaultTypeInternal;
extern GameCommandDefaultTypeInternal _GameCommand_default_instance_;
class GameResponse;
class GameResponseDefaultTypeInternal;
extern GameResponseDefaultTypeInternal _GameResponse_default_instance_;
class GameResponse_GameSet;
class GameResponse_GameSetDefaultTypeInternal;
extern GameResponse_GameSetDefaultTypeInternal _GameResponse_GameSet_default_instance_;
class Response;
class ResponseDefaultTypeInternal;
extern ResponseDefaultTypeInternal _Response_default_instance_;
class RoomCommand;
class RoomCommandDefaultTypeInternal;
extern RoomCommandDefaultTypeInternal _RoomCommand_default_instance_;
class RoomResponse;
class RoomResponseDefaultTypeInternal;
extern RoomResponseDefaultTypeInternal _RoomResponse_default_instance_;
class RoomResponse_RoomInfo;
class RoomResponse_RoomInfoDefaultTypeInternal;
extern RoomResponse_RoomInfoDefaultTypeInternal _RoomResponse_RoomInfo_default_instance_;
}  // namespace protobuf
}  // namespace tronol
namespace tronol {
namespace protobuf {

enum AccountCommand_CommandType {
  AccountCommand_CommandType_REGISTER = 0,
  AccountCommand_CommandType_LOGIN = 1,
  AccountCommand_CommandType_EDIT = 2
};
bool AccountCommand_CommandType_IsValid(int value);
const AccountCommand_CommandType AccountCommand_CommandType_CommandType_MIN = AccountCommand_CommandType_REGISTER;
const AccountCommand_CommandType AccountCommand_CommandType_CommandType_MAX = AccountCommand_CommandType_EDIT;
const int AccountCommand_CommandType_CommandType_ARRAYSIZE = AccountCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountCommand_CommandType_descriptor();
inline const ::std::string& AccountCommand_CommandType_Name(AccountCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountCommand_CommandType_descriptor(), value);
}
inline bool AccountCommand_CommandType_Parse(
    const ::std::string& name, AccountCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountCommand_CommandType>(
    AccountCommand_CommandType_descriptor(), name, value);
}
enum AccountResponse_ResponseType {
  AccountResponse_ResponseType_SUCCESS = 0,
  AccountResponse_ResponseType_INVALID_USERNAME = 1,
  AccountResponse_ResponseType_INVALID_PASSWORD = 2,
  AccountResponse_ResponseType_INVALID_TOKEN = 3
};
bool AccountResponse_ResponseType_IsValid(int value);
const AccountResponse_ResponseType AccountResponse_ResponseType_ResponseType_MIN = AccountResponse_ResponseType_SUCCESS;
const AccountResponse_ResponseType AccountResponse_ResponseType_ResponseType_MAX = AccountResponse_ResponseType_INVALID_TOKEN;
const int AccountResponse_ResponseType_ResponseType_ARRAYSIZE = AccountResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountResponse_ResponseType_descriptor();
inline const ::std::string& AccountResponse_ResponseType_Name(AccountResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountResponse_ResponseType_descriptor(), value);
}
inline bool AccountResponse_ResponseType_Parse(
    const ::std::string& name, AccountResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountResponse_ResponseType>(
    AccountResponse_ResponseType_descriptor(), name, value);
}
enum RoomCommand_CommandType {
  RoomCommand_CommandType_CREATE = 0,
  RoomCommand_CommandType_EDIT = 1,
  RoomCommand_CommandType_LIST = 2,
  RoomCommand_CommandType_ENTER = 3,
  RoomCommand_CommandType_LEAVE = 4
};
bool RoomCommand_CommandType_IsValid(int value);
const RoomCommand_CommandType RoomCommand_CommandType_CommandType_MIN = RoomCommand_CommandType_CREATE;
const RoomCommand_CommandType RoomCommand_CommandType_CommandType_MAX = RoomCommand_CommandType_LEAVE;
const int RoomCommand_CommandType_CommandType_ARRAYSIZE = RoomCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomCommand_CommandType_descriptor();
inline const ::std::string& RoomCommand_CommandType_Name(RoomCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomCommand_CommandType_descriptor(), value);
}
inline bool RoomCommand_CommandType_Parse(
    const ::std::string& name, RoomCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomCommand_CommandType>(
    RoomCommand_CommandType_descriptor(), name, value);
}
enum RoomResponse_ResponseType {
  RoomResponse_ResponseType_SUCCESS = 0,
  RoomResponse_ResponseType_INVALID_ROOM = 1
};
bool RoomResponse_ResponseType_IsValid(int value);
const RoomResponse_ResponseType RoomResponse_ResponseType_ResponseType_MIN = RoomResponse_ResponseType_SUCCESS;
const RoomResponse_ResponseType RoomResponse_ResponseType_ResponseType_MAX = RoomResponse_ResponseType_INVALID_ROOM;
const int RoomResponse_ResponseType_ResponseType_ARRAYSIZE = RoomResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomResponse_ResponseType_descriptor();
inline const ::std::string& RoomResponse_ResponseType_Name(RoomResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomResponse_ResponseType_descriptor(), value);
}
inline bool RoomResponse_ResponseType_Parse(
    const ::std::string& name, RoomResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomResponse_ResponseType>(
    RoomResponse_ResponseType_descriptor(), name, value);
}
enum GameCommand_CommandType {
  GameCommand_CommandType_ROOM = 0,
  GameCommand_CommandType_GAME = 1,
  GameCommand_CommandType_START = 2,
  GameCommand_CommandType_QUIT = 3
};
bool GameCommand_CommandType_IsValid(int value);
const GameCommand_CommandType GameCommand_CommandType_CommandType_MIN = GameCommand_CommandType_ROOM;
const GameCommand_CommandType GameCommand_CommandType_CommandType_MAX = GameCommand_CommandType_QUIT;
const int GameCommand_CommandType_CommandType_ARRAYSIZE = GameCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameCommand_CommandType_descriptor();
inline const ::std::string& GameCommand_CommandType_Name(GameCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameCommand_CommandType_descriptor(), value);
}
inline bool GameCommand_CommandType_Parse(
    const ::std::string& name, GameCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameCommand_CommandType>(
    GameCommand_CommandType_descriptor(), name, value);
}
enum GameResponse_ResponseType {
  GameResponse_ResponseType_SUCCESS = 0,
  GameResponse_ResponseType_ERROR = 1,
  GameResponse_ResponseType_ROOM = 2,
  GameResponse_ResponseType_GAME = 3,
  GameResponse_ResponseType_OVER = 4
};
bool GameResponse_ResponseType_IsValid(int value);
const GameResponse_ResponseType GameResponse_ResponseType_ResponseType_MIN = GameResponse_ResponseType_SUCCESS;
const GameResponse_ResponseType GameResponse_ResponseType_ResponseType_MAX = GameResponse_ResponseType_OVER;
const int GameResponse_ResponseType_ResponseType_ARRAYSIZE = GameResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameResponse_ResponseType_descriptor();
inline const ::std::string& GameResponse_ResponseType_Name(GameResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameResponse_ResponseType_descriptor(), value);
}
inline bool GameResponse_ResponseType_Parse(
    const ::std::string& name, GameResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameResponse_ResponseType>(
    GameResponse_ResponseType_descriptor(), name, value);
}
enum Command_CommandType {
  Command_CommandType_ACCOUNT = 0,
  Command_CommandType_ROOM = 1,
  Command_CommandType_GAME = 2
};
bool Command_CommandType_IsValid(int value);
const Command_CommandType Command_CommandType_CommandType_MIN = Command_CommandType_ACCOUNT;
const Command_CommandType Command_CommandType_CommandType_MAX = Command_CommandType_GAME;
const int Command_CommandType_CommandType_ARRAYSIZE = Command_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_CommandType_descriptor();
inline const ::std::string& Command_CommandType_Name(Command_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_CommandType_descriptor(), value);
}
inline bool Command_CommandType_Parse(
    const ::std::string& name, Command_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_CommandType>(
    Command_CommandType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_ACCOUNT = 0,
  Response_ResponseType_ROOM = 1,
  Response_ResponseType_GAME = 2
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_ACCOUNT;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_GAME;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
// ===================================================================

class AccountCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.AccountCommand) */ {
 public:
  AccountCommand();
  virtual ~AccountCommand();

  AccountCommand(const AccountCommand& from);

  inline AccountCommand& operator=(const AccountCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountCommand(AccountCommand&& from) noexcept
    : AccountCommand() {
    *this = ::std::move(from);
  }

  inline AccountCommand& operator=(AccountCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountCommand* internal_default_instance() {
    return reinterpret_cast<const AccountCommand*>(
               &_AccountCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    0;

  void Swap(AccountCommand* other);
  friend void swap(AccountCommand& a, AccountCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountCommand& from);
  void MergeFrom(const AccountCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AccountCommand_CommandType CommandType;
  static const CommandType REGISTER =
    AccountCommand_CommandType_REGISTER;
  static const CommandType LOGIN =
    AccountCommand_CommandType_LOGIN;
  static const CommandType EDIT =
    AccountCommand_CommandType_EDIT;
  static inline bool CommandType_IsValid(int value) {
    return AccountCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    AccountCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    AccountCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    AccountCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return AccountCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return AccountCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return AccountCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required string username = 2;
  bool has_username() const;
  void clear_username();
  static const int kUsernameFieldNumber = 2;
  const ::std::string& username() const;
  void set_username(const ::std::string& value);
  #if LANG_CXX11
  void set_username(::std::string&& value);
  #endif
  void set_username(const char* value);
  void set_username(const char* value, size_t size);
  ::std::string* mutable_username();
  ::std::string* release_username();
  void set_allocated_username(::std::string* username);

  // optional string password = 3;
  bool has_password() const;
  void clear_password();
  static const int kPasswordFieldNumber = 3;
  const ::std::string& password() const;
  void set_password(const ::std::string& value);
  #if LANG_CXX11
  void set_password(::std::string&& value);
  #endif
  void set_password(const char* value);
  void set_password(const char* value, size_t size);
  ::std::string* mutable_password();
  ::std::string* release_password();
  void set_allocated_password(::std::string* password);

  // optional string nickname = 4;
  bool has_nickname() const;
  void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  const ::std::string& nickname() const;
  void set_nickname(const ::std::string& value);
  #if LANG_CXX11
  void set_nickname(::std::string&& value);
  #endif
  void set_nickname(const char* value);
  void set_nickname(const char* value, size_t size);
  ::std::string* mutable_nickname();
  ::std::string* release_nickname();
  void set_allocated_nickname(::std::string* nickname);

  // optional string token = 5;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 5;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required .tronol.protobuf.AccountCommand.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::AccountCommand_CommandType type() const;
  void set_type(::tronol::protobuf::AccountCommand_CommandType value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.AccountCommand)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_username();
  void clear_has_username();
  void set_has_password();
  void clear_has_password();
  void set_has_nickname();
  void clear_has_nickname();
  void set_has_token();
  void clear_has_token();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr username_;
  ::google::protobuf::internal::ArenaStringPtr password_;
  ::google::protobuf::internal::ArenaStringPtr nickname_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int type_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsAccountCommandImpl();
};
// -------------------------------------------------------------------

class AccountResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.AccountResponse) */ {
 public:
  AccountResponse();
  virtual ~AccountResponse();

  AccountResponse(const AccountResponse& from);

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AccountResponse(AccountResponse&& from) noexcept
    : AccountResponse() {
    *this = ::std::move(from);
  }

  inline AccountResponse& operator=(AccountResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AccountResponse* internal_default_instance() {
    return reinterpret_cast<const AccountResponse*>(
               &_AccountResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    1;

  void Swap(AccountResponse* other);
  friend void swap(AccountResponse& a, AccountResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AccountResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  AccountResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const AccountResponse& from);
  void MergeFrom(const AccountResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(AccountResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef AccountResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS =
    AccountResponse_ResponseType_SUCCESS;
  static const ResponseType INVALID_USERNAME =
    AccountResponse_ResponseType_INVALID_USERNAME;
  static const ResponseType INVALID_PASSWORD =
    AccountResponse_ResponseType_INVALID_PASSWORD;
  static const ResponseType INVALID_TOKEN =
    AccountResponse_ResponseType_INVALID_TOKEN;
  static inline bool ResponseType_IsValid(int value) {
    return AccountResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    AccountResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    AccountResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    AccountResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return AccountResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return AccountResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return AccountResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string token = 2;
  bool has_token() const;
  void clear_token();
  static const int kTokenFieldNumber = 2;
  const ::std::string& token() const;
  void set_token(const ::std::string& value);
  #if LANG_CXX11
  void set_token(::std::string&& value);
  #endif
  void set_token(const char* value);
  void set_token(const char* value, size_t size);
  ::std::string* mutable_token();
  ::std::string* release_token();
  void set_allocated_token(::std::string* token);

  // required .tronol.protobuf.AccountResponse.ResponseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::AccountResponse_ResponseType type() const;
  void set_type(::tronol::protobuf::AccountResponse_ResponseType value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.AccountResponse)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_token();
  void clear_has_token();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr token_;
  int type_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsAccountResponseImpl();
};
// -------------------------------------------------------------------

class RoomCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.RoomCommand) */ {
 public:
  RoomCommand();
  virtual ~RoomCommand();

  RoomCommand(const RoomCommand& from);

  inline RoomCommand& operator=(const RoomCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomCommand(RoomCommand&& from) noexcept
    : RoomCommand() {
    *this = ::std::move(from);
  }

  inline RoomCommand& operator=(RoomCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomCommand* internal_default_instance() {
    return reinterpret_cast<const RoomCommand*>(
               &_RoomCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    2;

  void Swap(RoomCommand* other);
  friend void swap(RoomCommand& a, RoomCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomCommand& from);
  void MergeFrom(const RoomCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoomCommand_CommandType CommandType;
  static const CommandType CREATE =
    RoomCommand_CommandType_CREATE;
  static const CommandType EDIT =
    RoomCommand_CommandType_EDIT;
  static const CommandType LIST =
    RoomCommand_CommandType_LIST;
  static const CommandType ENTER =
    RoomCommand_CommandType_ENTER;
  static const CommandType LEAVE =
    RoomCommand_CommandType_LEAVE;
  static inline bool CommandType_IsValid(int value) {
    return RoomCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    RoomCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    RoomCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    RoomCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return RoomCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return RoomCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return RoomCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional string name = 3;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 3;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // required .tronol.protobuf.RoomCommand.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::RoomCommand_CommandType type() const;
  void set_type(::tronol::protobuf::RoomCommand_CommandType value);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // optional int32 wins = 4;
  bool has_wins() const;
  void clear_wins();
  static const int kWinsFieldNumber = 4;
  ::google::protobuf::int32 wins() const;
  void set_wins(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomCommand)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_wins();
  void clear_has_wins();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  int type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 wins_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsRoomCommandImpl();
};
// -------------------------------------------------------------------

class RoomResponse_RoomInfo : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.RoomResponse.RoomInfo) */ {
 public:
  RoomResponse_RoomInfo();
  virtual ~RoomResponse_RoomInfo();

  RoomResponse_RoomInfo(const RoomResponse_RoomInfo& from);

  inline RoomResponse_RoomInfo& operator=(const RoomResponse_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomResponse_RoomInfo(RoomResponse_RoomInfo&& from) noexcept
    : RoomResponse_RoomInfo() {
    *this = ::std::move(from);
  }

  inline RoomResponse_RoomInfo& operator=(RoomResponse_RoomInfo&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomResponse_RoomInfo& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomResponse_RoomInfo* internal_default_instance() {
    return reinterpret_cast<const RoomResponse_RoomInfo*>(
               &_RoomResponse_RoomInfo_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    3;

  void Swap(RoomResponse_RoomInfo* other);
  friend void swap(RoomResponse_RoomInfo& a, RoomResponse_RoomInfo& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomResponse_RoomInfo* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomResponse_RoomInfo* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomResponse_RoomInfo& from);
  void MergeFrom(const RoomResponse_RoomInfo& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomResponse_RoomInfo* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required string name = 2;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 2;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional string host = 3;
  bool has_host() const;
  void clear_host();
  static const int kHostFieldNumber = 3;
  const ::std::string& host() const;
  void set_host(const ::std::string& value);
  #if LANG_CXX11
  void set_host(::std::string&& value);
  #endif
  void set_host(const char* value);
  void set_host(const char* value, size_t size);
  ::std::string* mutable_host();
  ::std::string* release_host();
  void set_allocated_host(::std::string* host);

  // optional string status = 4;
  bool has_status() const;
  void clear_status();
  static const int kStatusFieldNumber = 4;
  const ::std::string& status() const;
  void set_status(const ::std::string& value);
  #if LANG_CXX11
  void set_status(::std::string&& value);
  #endif
  void set_status(const char* value);
  void set_status(const char* value, size_t size);
  ::std::string* mutable_status();
  ::std::string* release_status();
  void set_allocated_status(::std::string* status);

  // required int32 id = 1;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomResponse.RoomInfo)
 private:
  void set_has_id();
  void clear_has_id();
  void set_has_name();
  void clear_has_name();
  void set_has_host();
  void clear_has_host();
  void set_has_status();
  void clear_has_status();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::google::protobuf::internal::ArenaStringPtr host_;
  ::google::protobuf::internal::ArenaStringPtr status_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsRoomResponse_RoomInfoImpl();
};
// -------------------------------------------------------------------

class RoomResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.RoomResponse) */ {
 public:
  RoomResponse();
  virtual ~RoomResponse();

  RoomResponse(const RoomResponse& from);

  inline RoomResponse& operator=(const RoomResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RoomResponse(RoomResponse&& from) noexcept
    : RoomResponse() {
    *this = ::std::move(from);
  }

  inline RoomResponse& operator=(RoomResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RoomResponse* internal_default_instance() {
    return reinterpret_cast<const RoomResponse*>(
               &_RoomResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    4;

  void Swap(RoomResponse* other);
  friend void swap(RoomResponse& a, RoomResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RoomResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  RoomResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const RoomResponse& from);
  void MergeFrom(const RoomResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(RoomResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef RoomResponse_RoomInfo RoomInfo;

  typedef RoomResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS =
    RoomResponse_ResponseType_SUCCESS;
  static const ResponseType INVALID_ROOM =
    RoomResponse_ResponseType_INVALID_ROOM;
  static inline bool ResponseType_IsValid(int value) {
    return RoomResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    RoomResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    RoomResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    RoomResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return RoomResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return RoomResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return RoomResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .tronol.protobuf.RoomResponse.RoomInfo room = 3;
  int room_size() const;
  void clear_room();
  static const int kRoomFieldNumber = 3;
  const ::tronol::protobuf::RoomResponse_RoomInfo& room(int index) const;
  ::tronol::protobuf::RoomResponse_RoomInfo* mutable_room(int index);
  ::tronol::protobuf::RoomResponse_RoomInfo* add_room();
  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >*
      mutable_room();
  const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >&
      room() const;

  // required .tronol.protobuf.RoomResponse.ResponseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::RoomResponse_ResponseType type() const;
  void set_type(::tronol::protobuf::RoomResponse_ResponseType value);

  // optional int32 id = 2;
  bool has_id() const;
  void clear_id();
  static const int kIdFieldNumber = 2;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomResponse)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_id();
  void clear_has_id();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo > room_;
  int type_;
  ::google::protobuf::int32 id_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsRoomResponseImpl();
};
// -------------------------------------------------------------------

class GameCommand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.GameCommand) */ {
 public:
  GameCommand();
  virtual ~GameCommand();

  GameCommand(const GameCommand& from);

  inline GameCommand& operator=(const GameCommand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameCommand(GameCommand&& from) noexcept
    : GameCommand() {
    *this = ::std::move(from);
  }

  inline GameCommand& operator=(GameCommand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCommand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameCommand* internal_default_instance() {
    return reinterpret_cast<const GameCommand*>(
               &_GameCommand_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    5;

  void Swap(GameCommand* other);
  friend void swap(GameCommand& a, GameCommand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameCommand* New() const PROTOBUF_FINAL { return New(NULL); }

  GameCommand* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameCommand& from);
  void MergeFrom(const GameCommand& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameCommand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GameCommand_CommandType CommandType;
  static const CommandType ROOM =
    GameCommand_CommandType_ROOM;
  static const CommandType GAME =
    GameCommand_CommandType_GAME;
  static const CommandType START =
    GameCommand_CommandType_START;
  static const CommandType QUIT =
    GameCommand_CommandType_QUIT;
  static inline bool CommandType_IsValid(int value) {
    return GameCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    GameCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    GameCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    GameCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return GameCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return GameCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return GameCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated int32 dir = 3;
  int dir_size() const;
  void clear_dir();
  static const int kDirFieldNumber = 3;
  ::google::protobuf::int32 dir(int index) const;
  void set_dir(int index, ::google::protobuf::int32 value);
  void add_dir(::google::protobuf::int32 value);
  const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dir() const;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dir();

  // required .tronol.protobuf.GameCommand.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::GameCommand_CommandType type() const;
  void set_type(::tronol::protobuf::GameCommand_CommandType value);

  // optional int32 tick = 2;
  bool has_tick() const;
  void clear_tick();
  static const int kTickFieldNumber = 2;
  ::google::protobuf::int32 tick() const;
  void set_tick(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameCommand)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_tick();
  void clear_has_tick();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dir_;
  int type_;
  ::google::protobuf::int32 tick_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsGameCommandImpl();
};
// -------------------------------------------------------------------

class GameResponse_GameSet : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.GameResponse.GameSet) */ {
 public:
  GameResponse_GameSet();
  virtual ~GameResponse_GameSet();

  GameResponse_GameSet(const GameResponse_GameSet& from);

  inline GameResponse_GameSet& operator=(const GameResponse_GameSet& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameResponse_GameSet(GameResponse_GameSet&& from) noexcept
    : GameResponse_GameSet() {
    *this = ::std::move(from);
  }

  inline GameResponse_GameSet& operator=(GameResponse_GameSet&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResponse_GameSet& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameResponse_GameSet* internal_default_instance() {
    return reinterpret_cast<const GameResponse_GameSet*>(
               &_GameResponse_GameSet_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    6;

  void Swap(GameResponse_GameSet* other);
  friend void swap(GameResponse_GameSet& a, GameResponse_GameSet& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameResponse_GameSet* New() const PROTOBUF_FINAL { return New(NULL); }

  GameResponse_GameSet* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameResponse_GameSet& from);
  void MergeFrom(const GameResponse_GameSet& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameResponse_GameSet* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  bool has_x() const;
  void clear_x();
  static const int kXFieldNumber = 1;
  ::google::protobuf::int32 x() const;
  void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  bool has_y() const;
  void clear_y();
  static const int kYFieldNumber = 2;
  ::google::protobuf::int32 y() const;
  void set_y(::google::protobuf::int32 value);

  // required int32 v = 3;
  bool has_v() const;
  void clear_v();
  static const int kVFieldNumber = 3;
  ::google::protobuf::int32 v() const;
  void set_v(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameResponse.GameSet)
 private:
  void set_has_x();
  void clear_has_x();
  void set_has_y();
  void clear_has_y();
  void set_has_v();
  void clear_has_v();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 v_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsGameResponse_GameSetImpl();
};
// -------------------------------------------------------------------

class GameResponse : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.GameResponse) */ {
 public:
  GameResponse();
  virtual ~GameResponse();

  GameResponse(const GameResponse& from);

  inline GameResponse& operator=(const GameResponse& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GameResponse(GameResponse&& from) noexcept
    : GameResponse() {
    *this = ::std::move(from);
  }

  inline GameResponse& operator=(GameResponse&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResponse& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GameResponse* internal_default_instance() {
    return reinterpret_cast<const GameResponse*>(
               &_GameResponse_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    7;

  void Swap(GameResponse* other);
  friend void swap(GameResponse& a, GameResponse& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GameResponse* New() const PROTOBUF_FINAL { return New(NULL); }

  GameResponse* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const GameResponse& from);
  void MergeFrom(const GameResponse& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(GameResponse* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef GameResponse_GameSet GameSet;

  typedef GameResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS =
    GameResponse_ResponseType_SUCCESS;
  static const ResponseType ERROR =
    GameResponse_ResponseType_ERROR;
  static const ResponseType ROOM =
    GameResponse_ResponseType_ROOM;
  static const ResponseType GAME =
    GameResponse_ResponseType_GAME;
  static const ResponseType OVER =
    GameResponse_ResponseType_OVER;
  static inline bool ResponseType_IsValid(int value) {
    return GameResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    GameResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    GameResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    GameResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return GameResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return GameResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return GameResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // repeated .tronol.protobuf.GameResponse.GameSet set_at = 2;
  int set_at_size() const;
  void clear_set_at();
  static const int kSetAtFieldNumber = 2;
  const ::tronol::protobuf::GameResponse_GameSet& set_at(int index) const;
  ::tronol::protobuf::GameResponse_GameSet* mutable_set_at(int index);
  ::tronol::protobuf::GameResponse_GameSet* add_set_at();
  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >*
      mutable_set_at();
  const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >&
      set_at() const;

  // repeated string users = 3;
  int users_size() const;
  void clear_users();
  static const int kUsersFieldNumber = 3;
  const ::std::string& users(int index) const;
  ::std::string* mutable_users(int index);
  void set_users(int index, const ::std::string& value);
  #if LANG_CXX11
  void set_users(int index, ::std::string&& value);
  #endif
  void set_users(int index, const char* value);
  void set_users(int index, const char* value, size_t size);
  ::std::string* add_users();
  void add_users(const ::std::string& value);
  #if LANG_CXX11
  void add_users(::std::string&& value);
  #endif
  void add_users(const char* value);
  void add_users(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();

  // optional string winner = 5;
  bool has_winner() const;
  void clear_winner();
  static const int kWinnerFieldNumber = 5;
  const ::std::string& winner() const;
  void set_winner(const ::std::string& value);
  #if LANG_CXX11
  void set_winner(::std::string&& value);
  #endif
  void set_winner(const char* value);
  void set_winner(const char* value, size_t size);
  ::std::string* mutable_winner();
  ::std::string* release_winner();
  void set_allocated_winner(::std::string* winner);

  // required .tronol.protobuf.GameResponse.ResponseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::GameResponse_ResponseType type() const;
  void set_type(::tronol::protobuf::GameResponse_ResponseType value);

  // optional int32 tick = 4;
  bool has_tick() const;
  void clear_tick();
  static const int kTickFieldNumber = 4;
  ::google::protobuf::int32 tick() const;
  void set_tick(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameResponse)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_tick();
  void clear_has_tick();
  void set_has_winner();
  void clear_has_winner();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet > set_at_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  ::google::protobuf::internal::ArenaStringPtr winner_;
  int type_;
  ::google::protobuf::int32 tick_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsGameResponseImpl();
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.Command) */ {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Command(Command&& from) noexcept
    : Command() {
    *this = ::std::move(from);
  }

  inline Command& operator=(Command&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Command* internal_default_instance() {
    return reinterpret_cast<const Command*>(
               &_Command_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    8;

  void Swap(Command* other);
  friend void swap(Command& a, Command& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Command* New() const PROTOBUF_FINAL { return New(NULL); }

  Command* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Command* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Command_CommandType CommandType;
  static const CommandType ACCOUNT =
    Command_CommandType_ACCOUNT;
  static const CommandType ROOM =
    Command_CommandType_ROOM;
  static const CommandType GAME =
    Command_CommandType_GAME;
  static inline bool CommandType_IsValid(int value) {
    return Command_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Command_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Command_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Command_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Command_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Command_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Command_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .tronol.protobuf.AccountCommand account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::tronol::protobuf::AccountCommand& account() const;
  ::tronol::protobuf::AccountCommand* release_account();
  ::tronol::protobuf::AccountCommand* mutable_account();
  void set_allocated_account(::tronol::protobuf::AccountCommand* account);

  // optional .tronol.protobuf.RoomCommand room = 3;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 3;
  const ::tronol::protobuf::RoomCommand& room() const;
  ::tronol::protobuf::RoomCommand* release_room();
  ::tronol::protobuf::RoomCommand* mutable_room();
  void set_allocated_room(::tronol::protobuf::RoomCommand* room);

  // optional .tronol.protobuf.GameCommand game = 4;
  bool has_game() const;
  void clear_game();
  static const int kGameFieldNumber = 4;
  const ::tronol::protobuf::GameCommand& game() const;
  ::tronol::protobuf::GameCommand* release_game();
  ::tronol::protobuf::GameCommand* mutable_game();
  void set_allocated_game(::tronol::protobuf::GameCommand* game);

  // required .tronol.protobuf.Command.CommandType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::Command_CommandType type() const;
  void set_type(::tronol::protobuf::Command_CommandType value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.Command)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_account();
  void clear_has_account();
  void set_has_room();
  void clear_has_room();
  void set_has_game();
  void clear_has_game();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tronol::protobuf::AccountCommand* account_;
  ::tronol::protobuf::RoomCommand* room_;
  ::tronol::protobuf::GameCommand* game_;
  int type_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsCommandImpl();
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:tronol.protobuf.Response) */ {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Response(Response&& from) noexcept
    : Response() {
    *this = ::std::move(from);
  }

  inline Response& operator=(Response&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Response* internal_default_instance() {
    return reinterpret_cast<const Response*>(
               &_Response_default_instance_);
  }
  static PROTOBUF_CONSTEXPR int const kIndexInFileMessages =
    9;

  void Swap(Response* other);
  friend void swap(Response& a, Response& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Response* New() const PROTOBUF_FINAL { return New(NULL); }

  Response* New(::google::protobuf::Arena* arena) const PROTOBUF_FINAL;
  void CopyFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void MergeFrom(const ::google::protobuf::Message& from) PROTOBUF_FINAL;
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear() PROTOBUF_FINAL;
  bool IsInitialized() const PROTOBUF_FINAL;

  size_t ByteSizeLong() const PROTOBUF_FINAL;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) PROTOBUF_FINAL;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const PROTOBUF_FINAL;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const PROTOBUF_FINAL;
  int GetCachedSize() const PROTOBUF_FINAL { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const PROTOBUF_FINAL;
  void InternalSwap(Response* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const PROTOBUF_FINAL;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType ACCOUNT =
    Response_ResponseType_ACCOUNT;
  static const ResponseType ROOM =
    Response_ResponseType_ROOM;
  static const ResponseType GAME =
    Response_ResponseType_GAME;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .tronol.protobuf.AccountResponse account = 2;
  bool has_account() const;
  void clear_account();
  static const int kAccountFieldNumber = 2;
  const ::tronol::protobuf::AccountResponse& account() const;
  ::tronol::protobuf::AccountResponse* release_account();
  ::tronol::protobuf::AccountResponse* mutable_account();
  void set_allocated_account(::tronol::protobuf::AccountResponse* account);

  // optional .tronol.protobuf.RoomResponse room = 3;
  bool has_room() const;
  void clear_room();
  static const int kRoomFieldNumber = 3;
  const ::tronol::protobuf::RoomResponse& room() const;
  ::tronol::protobuf::RoomResponse* release_room();
  ::tronol::protobuf::RoomResponse* mutable_room();
  void set_allocated_room(::tronol::protobuf::RoomResponse* room);

  // optional .tronol.protobuf.GameResponse game = 4;
  bool has_game() const;
  void clear_game();
  static const int kGameFieldNumber = 4;
  const ::tronol::protobuf::GameResponse& game() const;
  ::tronol::protobuf::GameResponse* release_game();
  ::tronol::protobuf::GameResponse* mutable_game();
  void set_allocated_game(::tronol::protobuf::GameResponse* game);

  // required .tronol.protobuf.Response.ResponseType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::tronol::protobuf::Response_ResponseType type() const;
  void set_type(::tronol::protobuf::Response_ResponseType value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.Response)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_account();
  void clear_has_account();
  void set_has_room();
  void clear_has_room();
  void set_has_game();
  void clear_has_game();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable int _cached_size_;
  ::tronol::protobuf::AccountResponse* account_;
  ::tronol::protobuf::RoomResponse* room_;
  ::tronol::protobuf::GameResponse* game_;
  int type_;
  friend struct ::protobuf_tron_2eproto::TableStruct;
  friend void ::protobuf_tron_2eproto::InitDefaultsResponseImpl();
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// AccountCommand

// required .tronol.protobuf.AccountCommand.CommandType type = 1;
inline bool AccountCommand::has_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountCommand::set_has_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::AccountCommand_CommandType AccountCommand::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountCommand.type)
  return static_cast< ::tronol::protobuf::AccountCommand_CommandType >(type_);
}
inline void AccountCommand::set_type(::tronol::protobuf::AccountCommand_CommandType value) {
  assert(::tronol::protobuf::AccountCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountCommand.type)
}

// required string username = 2;
inline bool AccountCommand::has_username() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountCommand::set_has_username() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountCommand::clear_has_username() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountCommand::clear_username() {
  username_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_username();
}
inline const ::std::string& AccountCommand::username() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountCommand.username)
  return username_.GetNoArena();
}
inline void AccountCommand::set_username(const ::std::string& value) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountCommand.username)
}
#if LANG_CXX11
inline void AccountCommand::set_username(::std::string&& value) {
  set_has_username();
  username_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.AccountCommand.username)
}
#endif
inline void AccountCommand::set_username(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.AccountCommand.username)
}
inline void AccountCommand::set_username(const char* value, size_t size) {
  set_has_username();
  username_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.AccountCommand.username)
}
inline ::std::string* AccountCommand::mutable_username() {
  set_has_username();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.AccountCommand.username)
  return username_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountCommand::release_username() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.AccountCommand.username)
  clear_has_username();
  return username_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountCommand::set_allocated_username(::std::string* username) {
  if (username != NULL) {
    set_has_username();
  } else {
    clear_has_username();
  }
  username_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), username);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.AccountCommand.username)
}

// optional string password = 3;
inline bool AccountCommand::has_password() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountCommand::set_has_password() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountCommand::clear_has_password() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountCommand::clear_password() {
  password_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_password();
}
inline const ::std::string& AccountCommand::password() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountCommand.password)
  return password_.GetNoArena();
}
inline void AccountCommand::set_password(const ::std::string& value) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountCommand.password)
}
#if LANG_CXX11
inline void AccountCommand::set_password(::std::string&& value) {
  set_has_password();
  password_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.AccountCommand.password)
}
#endif
inline void AccountCommand::set_password(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.AccountCommand.password)
}
inline void AccountCommand::set_password(const char* value, size_t size) {
  set_has_password();
  password_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.AccountCommand.password)
}
inline ::std::string* AccountCommand::mutable_password() {
  set_has_password();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.AccountCommand.password)
  return password_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountCommand::release_password() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.AccountCommand.password)
  clear_has_password();
  return password_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountCommand::set_allocated_password(::std::string* password) {
  if (password != NULL) {
    set_has_password();
  } else {
    clear_has_password();
  }
  password_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), password);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.AccountCommand.password)
}

// optional string nickname = 4;
inline bool AccountCommand::has_nickname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountCommand::set_has_nickname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountCommand::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountCommand::clear_nickname() {
  nickname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_nickname();
}
inline const ::std::string& AccountCommand::nickname() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountCommand.nickname)
  return nickname_.GetNoArena();
}
inline void AccountCommand::set_nickname(const ::std::string& value) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountCommand.nickname)
}
#if LANG_CXX11
inline void AccountCommand::set_nickname(::std::string&& value) {
  set_has_nickname();
  nickname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.AccountCommand.nickname)
}
#endif
inline void AccountCommand::set_nickname(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.AccountCommand.nickname)
}
inline void AccountCommand::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  nickname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.AccountCommand.nickname)
}
inline ::std::string* AccountCommand::mutable_nickname() {
  set_has_nickname();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.AccountCommand.nickname)
  return nickname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountCommand::release_nickname() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.AccountCommand.nickname)
  clear_has_nickname();
  return nickname_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountCommand::set_allocated_nickname(::std::string* nickname) {
  if (nickname != NULL) {
    set_has_nickname();
  } else {
    clear_has_nickname();
  }
  nickname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), nickname);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.AccountCommand.nickname)
}

// optional string token = 5;
inline bool AccountCommand::has_token() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountCommand::set_has_token() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountCommand::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& AccountCommand::token() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountCommand.token)
  return token_.GetNoArena();
}
inline void AccountCommand::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountCommand.token)
}
#if LANG_CXX11
inline void AccountCommand::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.AccountCommand.token)
}
#endif
inline void AccountCommand::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.AccountCommand.token)
}
inline void AccountCommand::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.AccountCommand.token)
}
inline ::std::string* AccountCommand::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.AccountCommand.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountCommand::release_token() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.AccountCommand.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountCommand::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.AccountCommand.token)
}

// -------------------------------------------------------------------

// AccountResponse

// required .tronol.protobuf.AccountResponse.ResponseType type = 1;
inline bool AccountResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::AccountResponse_ResponseType AccountResponse::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountResponse.type)
  return static_cast< ::tronol::protobuf::AccountResponse_ResponseType >(type_);
}
inline void AccountResponse::set_type(::tronol::protobuf::AccountResponse_ResponseType value) {
  assert(::tronol::protobuf::AccountResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountResponse.type)
}

// optional string token = 2;
inline bool AccountResponse::has_token() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountResponse::set_has_token() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountResponse::clear_token() {
  token_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_token();
}
inline const ::std::string& AccountResponse::token() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.AccountResponse.token)
  return token_.GetNoArena();
}
inline void AccountResponse::set_token(const ::std::string& value) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.AccountResponse.token)
}
#if LANG_CXX11
inline void AccountResponse::set_token(::std::string&& value) {
  set_has_token();
  token_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.AccountResponse.token)
}
#endif
inline void AccountResponse::set_token(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.AccountResponse.token)
}
inline void AccountResponse::set_token(const char* value, size_t size) {
  set_has_token();
  token_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.AccountResponse.token)
}
inline ::std::string* AccountResponse::mutable_token() {
  set_has_token();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.AccountResponse.token)
  return token_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* AccountResponse::release_token() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.AccountResponse.token)
  clear_has_token();
  return token_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void AccountResponse::set_allocated_token(::std::string* token) {
  if (token != NULL) {
    set_has_token();
  } else {
    clear_has_token();
  }
  token_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), token);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.AccountResponse.token)
}

// -------------------------------------------------------------------

// RoomCommand

// required .tronol.protobuf.RoomCommand.CommandType type = 1;
inline bool RoomCommand::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomCommand::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::RoomCommand_CommandType RoomCommand::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomCommand.type)
  return static_cast< ::tronol::protobuf::RoomCommand_CommandType >(type_);
}
inline void RoomCommand::set_type(::tronol::protobuf::RoomCommand_CommandType value) {
  assert(::tronol::protobuf::RoomCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomCommand.type)
}

// optional int32 id = 2;
inline bool RoomCommand::has_id() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomCommand::set_has_id() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomCommand::id() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomCommand.id)
  return id_;
}
inline void RoomCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomCommand.id)
}

// optional string name = 3;
inline bool RoomCommand::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomCommand::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomCommand::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomCommand::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RoomCommand::name() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomCommand.name)
  return name_.GetNoArena();
}
inline void RoomCommand::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomCommand.name)
}
#if LANG_CXX11
inline void RoomCommand::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.RoomCommand.name)
}
#endif
inline void RoomCommand::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.RoomCommand.name)
}
inline void RoomCommand::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.RoomCommand.name)
}
inline ::std::string* RoomCommand::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.RoomCommand.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomCommand::release_name() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.RoomCommand.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomCommand::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.RoomCommand.name)
}

// optional int32 wins = 4;
inline bool RoomCommand::has_wins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomCommand::set_has_wins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomCommand::clear_has_wins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomCommand::clear_wins() {
  wins_ = 0;
  clear_has_wins();
}
inline ::google::protobuf::int32 RoomCommand::wins() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomCommand.wins)
  return wins_;
}
inline void RoomCommand::set_wins(::google::protobuf::int32 value) {
  set_has_wins();
  wins_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomCommand.wins)
}

// -------------------------------------------------------------------

// RoomResponse_RoomInfo

// required int32 id = 1;
inline bool RoomResponse_RoomInfo::has_id() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_id() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomResponse_RoomInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomResponse_RoomInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomResponse_RoomInfo::id() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.RoomInfo.id)
  return id_;
}
inline void RoomResponse_RoomInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.RoomInfo.id)
}

// required string name = 2;
inline bool RoomResponse_RoomInfo::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomResponse_RoomInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomResponse_RoomInfo::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_name();
}
inline const ::std::string& RoomResponse_RoomInfo::name() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.RoomInfo.name)
  return name_.GetNoArena();
}
inline void RoomResponse_RoomInfo::set_name(const ::std::string& value) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.RoomInfo.name)
}
#if LANG_CXX11
inline void RoomResponse_RoomInfo::set_name(::std::string&& value) {
  set_has_name();
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.RoomResponse.RoomInfo.name)
}
#endif
inline void RoomResponse_RoomInfo::set_name(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.RoomResponse.RoomInfo.name)
}
inline void RoomResponse_RoomInfo::set_name(const char* value, size_t size) {
  set_has_name();
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.RoomResponse.RoomInfo.name)
}
inline ::std::string* RoomResponse_RoomInfo::mutable_name() {
  set_has_name();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.RoomResponse.RoomInfo.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomResponse_RoomInfo::release_name() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.RoomResponse.RoomInfo.name)
  clear_has_name();
  return name_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomResponse_RoomInfo::set_allocated_name(::std::string* name) {
  if (name != NULL) {
    set_has_name();
  } else {
    clear_has_name();
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.RoomResponse.RoomInfo.name)
}

// optional string host = 3;
inline bool RoomResponse_RoomInfo::has_host() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_host() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomResponse_RoomInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomResponse_RoomInfo::clear_host() {
  host_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_host();
}
inline const ::std::string& RoomResponse_RoomInfo::host() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.RoomInfo.host)
  return host_.GetNoArena();
}
inline void RoomResponse_RoomInfo::set_host(const ::std::string& value) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.RoomInfo.host)
}
#if LANG_CXX11
inline void RoomResponse_RoomInfo::set_host(::std::string&& value) {
  set_has_host();
  host_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.RoomResponse.RoomInfo.host)
}
#endif
inline void RoomResponse_RoomInfo::set_host(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.RoomResponse.RoomInfo.host)
}
inline void RoomResponse_RoomInfo::set_host(const char* value, size_t size) {
  set_has_host();
  host_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.RoomResponse.RoomInfo.host)
}
inline ::std::string* RoomResponse_RoomInfo::mutable_host() {
  set_has_host();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.RoomResponse.RoomInfo.host)
  return host_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomResponse_RoomInfo::release_host() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.RoomResponse.RoomInfo.host)
  clear_has_host();
  return host_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomResponse_RoomInfo::set_allocated_host(::std::string* host) {
  if (host != NULL) {
    set_has_host();
  } else {
    clear_has_host();
  }
  host_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), host);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.RoomResponse.RoomInfo.host)
}

// optional string status = 4;
inline bool RoomResponse_RoomInfo::has_status() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_status() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomResponse_RoomInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomResponse_RoomInfo::clear_status() {
  status_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_status();
}
inline const ::std::string& RoomResponse_RoomInfo::status() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.RoomInfo.status)
  return status_.GetNoArena();
}
inline void RoomResponse_RoomInfo::set_status(const ::std::string& value) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.RoomInfo.status)
}
#if LANG_CXX11
inline void RoomResponse_RoomInfo::set_status(::std::string&& value) {
  set_has_status();
  status_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.RoomResponse.RoomInfo.status)
}
#endif
inline void RoomResponse_RoomInfo::set_status(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.RoomResponse.RoomInfo.status)
}
inline void RoomResponse_RoomInfo::set_status(const char* value, size_t size) {
  set_has_status();
  status_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.RoomResponse.RoomInfo.status)
}
inline ::std::string* RoomResponse_RoomInfo::mutable_status() {
  set_has_status();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.RoomResponse.RoomInfo.status)
  return status_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* RoomResponse_RoomInfo::release_status() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.RoomResponse.RoomInfo.status)
  clear_has_status();
  return status_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void RoomResponse_RoomInfo::set_allocated_status(::std::string* status) {
  if (status != NULL) {
    set_has_status();
  } else {
    clear_has_status();
  }
  status_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), status);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.RoomResponse.RoomInfo.status)
}

// -------------------------------------------------------------------

// RoomResponse

// required .tronol.protobuf.RoomResponse.ResponseType type = 1;
inline bool RoomResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::RoomResponse_ResponseType RoomResponse::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.type)
  return static_cast< ::tronol::protobuf::RoomResponse_ResponseType >(type_);
}
inline void RoomResponse::set_type(::tronol::protobuf::RoomResponse_ResponseType value) {
  assert(::tronol::protobuf::RoomResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.type)
}

// optional int32 id = 2;
inline bool RoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomResponse::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomResponse::id() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.id)
  return id_;
}
inline void RoomResponse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.RoomResponse.id)
}

// repeated .tronol.protobuf.RoomResponse.RoomInfo room = 3;
inline int RoomResponse::room_size() const {
  return room_.size();
}
inline void RoomResponse::clear_room() {
  room_.Clear();
}
inline const ::tronol::protobuf::RoomResponse_RoomInfo& RoomResponse::room(int index) const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.RoomResponse.room)
  return room_.Get(index);
}
inline ::tronol::protobuf::RoomResponse_RoomInfo* RoomResponse::mutable_room(int index) {
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.RoomResponse.room)
  return room_.Mutable(index);
}
inline ::tronol::protobuf::RoomResponse_RoomInfo* RoomResponse::add_room() {
  // @@protoc_insertion_point(field_add:tronol.protobuf.RoomResponse.room)
  return room_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >*
RoomResponse::mutable_room() {
  // @@protoc_insertion_point(field_mutable_list:tronol.protobuf.RoomResponse.room)
  return &room_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >&
RoomResponse::room() const {
  // @@protoc_insertion_point(field_list:tronol.protobuf.RoomResponse.room)
  return room_;
}

// -------------------------------------------------------------------

// GameCommand

// required .tronol.protobuf.GameCommand.CommandType type = 1;
inline bool GameCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::GameCommand_CommandType GameCommand::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameCommand.type)
  return static_cast< ::tronol::protobuf::GameCommand_CommandType >(type_);
}
inline void GameCommand::set_type(::tronol::protobuf::GameCommand_CommandType value) {
  assert(::tronol::protobuf::GameCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameCommand.type)
}

// optional int32 tick = 2;
inline bool GameCommand::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameCommand::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameCommand::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameCommand::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
inline ::google::protobuf::int32 GameCommand::tick() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameCommand.tick)
  return tick_;
}
inline void GameCommand::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameCommand.tick)
}

// repeated int32 dir = 3;
inline int GameCommand::dir_size() const {
  return dir_.size();
}
inline void GameCommand::clear_dir() {
  dir_.Clear();
}
inline ::google::protobuf::int32 GameCommand::dir(int index) const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameCommand.dir)
  return dir_.Get(index);
}
inline void GameCommand::set_dir(int index, ::google::protobuf::int32 value) {
  dir_.Set(index, value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameCommand.dir)
}
inline void GameCommand::add_dir(::google::protobuf::int32 value) {
  dir_.Add(value);
  // @@protoc_insertion_point(field_add:tronol.protobuf.GameCommand.dir)
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GameCommand::dir() const {
  // @@protoc_insertion_point(field_list:tronol.protobuf.GameCommand.dir)
  return dir_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GameCommand::mutable_dir() {
  // @@protoc_insertion_point(field_mutable_list:tronol.protobuf.GameCommand.dir)
  return &dir_;
}

// -------------------------------------------------------------------

// GameResponse_GameSet

// required int32 x = 1;
inline bool GameResponse_GameSet::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResponse_GameSet::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResponse_GameSet::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResponse_GameSet::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 GameResponse_GameSet::x() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.GameSet.x)
  return x_;
}
inline void GameResponse_GameSet::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.GameSet.x)
}

// required int32 y = 2;
inline bool GameResponse_GameSet::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameResponse_GameSet::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameResponse_GameSet::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameResponse_GameSet::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 GameResponse_GameSet::y() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.GameSet.y)
  return y_;
}
inline void GameResponse_GameSet::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.GameSet.y)
}

// required int32 v = 3;
inline bool GameResponse_GameSet::has_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameResponse_GameSet::set_has_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameResponse_GameSet::clear_has_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameResponse_GameSet::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 GameResponse_GameSet::v() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.GameSet.v)
  return v_;
}
inline void GameResponse_GameSet::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.GameSet.v)
}

// -------------------------------------------------------------------

// GameResponse

// required .tronol.protobuf.GameResponse.ResponseType type = 1;
inline bool GameResponse::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameResponse::set_has_type() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::GameResponse_ResponseType GameResponse::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.type)
  return static_cast< ::tronol::protobuf::GameResponse_ResponseType >(type_);
}
inline void GameResponse::set_type(::tronol::protobuf::GameResponse_ResponseType value) {
  assert(::tronol::protobuf::GameResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.type)
}

// repeated .tronol.protobuf.GameResponse.GameSet set_at = 2;
inline int GameResponse::set_at_size() const {
  return set_at_.size();
}
inline void GameResponse::clear_set_at() {
  set_at_.Clear();
}
inline const ::tronol::protobuf::GameResponse_GameSet& GameResponse::set_at(int index) const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.set_at)
  return set_at_.Get(index);
}
inline ::tronol::protobuf::GameResponse_GameSet* GameResponse::mutable_set_at(int index) {
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.GameResponse.set_at)
  return set_at_.Mutable(index);
}
inline ::tronol::protobuf::GameResponse_GameSet* GameResponse::add_set_at() {
  // @@protoc_insertion_point(field_add:tronol.protobuf.GameResponse.set_at)
  return set_at_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >*
GameResponse::mutable_set_at() {
  // @@protoc_insertion_point(field_mutable_list:tronol.protobuf.GameResponse.set_at)
  return &set_at_;
}
inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >&
GameResponse::set_at() const {
  // @@protoc_insertion_point(field_list:tronol.protobuf.GameResponse.set_at)
  return set_at_;
}

// repeated string users = 3;
inline int GameResponse::users_size() const {
  return users_.size();
}
inline void GameResponse::clear_users() {
  users_.Clear();
}
inline const ::std::string& GameResponse::users(int index) const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.users)
  return users_.Get(index);
}
inline ::std::string* GameResponse::mutable_users(int index) {
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.GameResponse.users)
  return users_.Mutable(index);
}
inline void GameResponse::set_users(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.users)
  users_.Mutable(index)->assign(value);
}
#if LANG_CXX11
inline void GameResponse::set_users(int index, ::std::string&& value) {
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.users)
  users_.Mutable(index)->assign(std::move(value));
}
#endif
inline void GameResponse::set_users(int index, const char* value) {
  GOOGLE_DCHECK(value != NULL);
  users_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.GameResponse.users)
}
inline void GameResponse::set_users(int index, const char* value, size_t size) {
  users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.GameResponse.users)
}
inline ::std::string* GameResponse::add_users() {
  // @@protoc_insertion_point(field_add_mutable:tronol.protobuf.GameResponse.users)
  return users_.Add();
}
inline void GameResponse::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:tronol.protobuf.GameResponse.users)
}
#if LANG_CXX11
inline void GameResponse::add_users(::std::string&& value) {
  users_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:tronol.protobuf.GameResponse.users)
}
#endif
inline void GameResponse::add_users(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  users_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:tronol.protobuf.GameResponse.users)
}
inline void GameResponse::add_users(const char* value, size_t size) {
  users_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:tronol.protobuf.GameResponse.users)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameResponse::users() const {
  // @@protoc_insertion_point(field_list:tronol.protobuf.GameResponse.users)
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameResponse::mutable_users() {
  // @@protoc_insertion_point(field_mutable_list:tronol.protobuf.GameResponse.users)
  return &users_;
}

// optional int32 tick = 4;
inline bool GameResponse::has_tick() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameResponse::set_has_tick() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameResponse::clear_has_tick() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameResponse::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
inline ::google::protobuf::int32 GameResponse::tick() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.tick)
  return tick_;
}
inline void GameResponse::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.tick)
}

// optional string winner = 5;
inline bool GameResponse::has_winner() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResponse::set_has_winner() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResponse::clear_has_winner() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResponse::clear_winner() {
  winner_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  clear_has_winner();
}
inline const ::std::string& GameResponse::winner() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.GameResponse.winner)
  return winner_.GetNoArena();
}
inline void GameResponse::set_winner(const ::std::string& value) {
  set_has_winner();
  winner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:tronol.protobuf.GameResponse.winner)
}
#if LANG_CXX11
inline void GameResponse::set_winner(::std::string&& value) {
  set_has_winner();
  winner_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:tronol.protobuf.GameResponse.winner)
}
#endif
inline void GameResponse::set_winner(const char* value) {
  GOOGLE_DCHECK(value != NULL);
  set_has_winner();
  winner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:tronol.protobuf.GameResponse.winner)
}
inline void GameResponse::set_winner(const char* value, size_t size) {
  set_has_winner();
  winner_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:tronol.protobuf.GameResponse.winner)
}
inline ::std::string* GameResponse::mutable_winner() {
  set_has_winner();
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.GameResponse.winner)
  return winner_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* GameResponse::release_winner() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.GameResponse.winner)
  clear_has_winner();
  return winner_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void GameResponse::set_allocated_winner(::std::string* winner) {
  if (winner != NULL) {
    set_has_winner();
  } else {
    clear_has_winner();
  }
  winner_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), winner);
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.GameResponse.winner)
}

// -------------------------------------------------------------------

// Command

// required .tronol.protobuf.Command.CommandType type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::Command_CommandType Command::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.Command.type)
  return static_cast< ::tronol::protobuf::Command_CommandType >(type_);
}
inline void Command::set_type(::tronol::protobuf::Command_CommandType value) {
  assert(::tronol::protobuf::Command_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.Command.type)
}

// optional .tronol.protobuf.AccountCommand account = 2;
inline bool Command::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_account() {
  if (account_ != NULL) account_->Clear();
  clear_has_account();
}
inline const ::tronol::protobuf::AccountCommand& Command::account() const {
  const ::tronol::protobuf::AccountCommand* p = account_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Command.account)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::AccountCommand*>(
      &::tronol::protobuf::_AccountCommand_default_instance_);
}
inline ::tronol::protobuf::AccountCommand* Command::release_account() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Command.account)
  clear_has_account();
  ::tronol::protobuf::AccountCommand* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::tronol::protobuf::AccountCommand* Command::mutable_account() {
  set_has_account();
  if (account_ == NULL) {
    account_ = new ::tronol::protobuf::AccountCommand;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Command.account)
  return account_;
}
inline void Command::set_allocated_account(::tronol::protobuf::AccountCommand* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    set_has_account();
  } else {
    clear_has_account();
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Command.account)
}

// optional .tronol.protobuf.RoomCommand room = 3;
inline bool Command::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_room() {
  if (room_ != NULL) room_->Clear();
  clear_has_room();
}
inline const ::tronol::protobuf::RoomCommand& Command::room() const {
  const ::tronol::protobuf::RoomCommand* p = room_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Command.room)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::RoomCommand*>(
      &::tronol::protobuf::_RoomCommand_default_instance_);
}
inline ::tronol::protobuf::RoomCommand* Command::release_room() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Command.room)
  clear_has_room();
  ::tronol::protobuf::RoomCommand* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::tronol::protobuf::RoomCommand* Command::mutable_room() {
  set_has_room();
  if (room_ == NULL) {
    room_ = new ::tronol::protobuf::RoomCommand;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Command.room)
  return room_;
}
inline void Command::set_allocated_room(::tronol::protobuf::RoomCommand* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    set_has_room();
  } else {
    clear_has_room();
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Command.room)
}

// optional .tronol.protobuf.GameCommand game = 4;
inline bool Command::has_game() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_game() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_game() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_game() {
  if (game_ != NULL) game_->Clear();
  clear_has_game();
}
inline const ::tronol::protobuf::GameCommand& Command::game() const {
  const ::tronol::protobuf::GameCommand* p = game_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Command.game)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::GameCommand*>(
      &::tronol::protobuf::_GameCommand_default_instance_);
}
inline ::tronol::protobuf::GameCommand* Command::release_game() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Command.game)
  clear_has_game();
  ::tronol::protobuf::GameCommand* temp = game_;
  game_ = NULL;
  return temp;
}
inline ::tronol::protobuf::GameCommand* Command::mutable_game() {
  set_has_game();
  if (game_ == NULL) {
    game_ = new ::tronol::protobuf::GameCommand;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Command.game)
  return game_;
}
inline void Command::set_allocated_game(::tronol::protobuf::GameCommand* game) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete game_;
  }
  if (game) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game, submessage_arena);
    }
    set_has_game();
  } else {
    clear_has_game();
  }
  game_ = game;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Command.game)
}

// -------------------------------------------------------------------

// Response

// required .tronol.protobuf.Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::Response_ResponseType Response::type() const {
  // @@protoc_insertion_point(field_get:tronol.protobuf.Response.type)
  return static_cast< ::tronol::protobuf::Response_ResponseType >(type_);
}
inline void Response::set_type(::tronol::protobuf::Response_ResponseType value) {
  assert(::tronol::protobuf::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:tronol.protobuf.Response.type)
}

// optional .tronol.protobuf.AccountResponse account = 2;
inline bool Response::has_account() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_account() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_account() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_account() {
  if (account_ != NULL) account_->Clear();
  clear_has_account();
}
inline const ::tronol::protobuf::AccountResponse& Response::account() const {
  const ::tronol::protobuf::AccountResponse* p = account_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Response.account)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::AccountResponse*>(
      &::tronol::protobuf::_AccountResponse_default_instance_);
}
inline ::tronol::protobuf::AccountResponse* Response::release_account() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Response.account)
  clear_has_account();
  ::tronol::protobuf::AccountResponse* temp = account_;
  account_ = NULL;
  return temp;
}
inline ::tronol::protobuf::AccountResponse* Response::mutable_account() {
  set_has_account();
  if (account_ == NULL) {
    account_ = new ::tronol::protobuf::AccountResponse;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Response.account)
  return account_;
}
inline void Response::set_allocated_account(::tronol::protobuf::AccountResponse* account) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete account_;
  }
  if (account) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      account = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, account, submessage_arena);
    }
    set_has_account();
  } else {
    clear_has_account();
  }
  account_ = account;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Response.account)
}

// optional .tronol.protobuf.RoomResponse room = 3;
inline bool Response::has_room() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_room() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_room() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_room() {
  if (room_ != NULL) room_->Clear();
  clear_has_room();
}
inline const ::tronol::protobuf::RoomResponse& Response::room() const {
  const ::tronol::protobuf::RoomResponse* p = room_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Response.room)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::RoomResponse*>(
      &::tronol::protobuf::_RoomResponse_default_instance_);
}
inline ::tronol::protobuf::RoomResponse* Response::release_room() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Response.room)
  clear_has_room();
  ::tronol::protobuf::RoomResponse* temp = room_;
  room_ = NULL;
  return temp;
}
inline ::tronol::protobuf::RoomResponse* Response::mutable_room() {
  set_has_room();
  if (room_ == NULL) {
    room_ = new ::tronol::protobuf::RoomResponse;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Response.room)
  return room_;
}
inline void Response::set_allocated_room(::tronol::protobuf::RoomResponse* room) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete room_;
  }
  if (room) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      room = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, room, submessage_arena);
    }
    set_has_room();
  } else {
    clear_has_room();
  }
  room_ = room;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Response.room)
}

// optional .tronol.protobuf.GameResponse game = 4;
inline bool Response::has_game() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_game() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_game() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_game() {
  if (game_ != NULL) game_->Clear();
  clear_has_game();
}
inline const ::tronol::protobuf::GameResponse& Response::game() const {
  const ::tronol::protobuf::GameResponse* p = game_;
  // @@protoc_insertion_point(field_get:tronol.protobuf.Response.game)
  return p != NULL ? *p : *reinterpret_cast<const ::tronol::protobuf::GameResponse*>(
      &::tronol::protobuf::_GameResponse_default_instance_);
}
inline ::tronol::protobuf::GameResponse* Response::release_game() {
  // @@protoc_insertion_point(field_release:tronol.protobuf.Response.game)
  clear_has_game();
  ::tronol::protobuf::GameResponse* temp = game_;
  game_ = NULL;
  return temp;
}
inline ::tronol::protobuf::GameResponse* Response::mutable_game() {
  set_has_game();
  if (game_ == NULL) {
    game_ = new ::tronol::protobuf::GameResponse;
  }
  // @@protoc_insertion_point(field_mutable:tronol.protobuf.Response.game)
  return game_;
}
inline void Response::set_allocated_game(::tronol::protobuf::GameResponse* game) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete game_;
  }
  if (game) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      game = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, game, submessage_arena);
    }
    set_has_game();
  } else {
    clear_has_game();
  }
  game_ = game;
  // @@protoc_insertion_point(field_set_allocated:tronol.protobuf.Response.game)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace tronol

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::tronol::protobuf::AccountCommand_CommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::AccountCommand_CommandType>() {
  return ::tronol::protobuf::AccountCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::AccountResponse_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::AccountResponse_ResponseType>() {
  return ::tronol::protobuf::AccountResponse_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::RoomCommand_CommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::RoomCommand_CommandType>() {
  return ::tronol::protobuf::RoomCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::RoomResponse_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::RoomResponse_ResponseType>() {
  return ::tronol::protobuf::RoomResponse_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::GameCommand_CommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::GameCommand_CommandType>() {
  return ::tronol::protobuf::GameCommand_CommandType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::GameResponse_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::GameResponse_ResponseType>() {
  return ::tronol::protobuf::GameResponse_ResponseType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::Command_CommandType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::Command_CommandType>() {
  return ::tronol::protobuf::Command_CommandType_descriptor();
}
template <> struct is_proto_enum< ::tronol::protobuf::Response_ResponseType> : ::google::protobuf::internal::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::Response_ResponseType>() {
  return ::tronol::protobuf::Response_ResponseType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tron_2eproto__INCLUDED

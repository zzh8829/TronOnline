// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: tron.proto

#ifndef PROTOBUF_tron_2eproto__INCLUDED
#define PROTOBUF_tron_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace tronol {
namespace protobuf {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_tron_2eproto();
void protobuf_AssignDesc_tron_2eproto();
void protobuf_ShutdownFile_tron_2eproto();

class AccountCommand;
class AccountResponse;
class RoomCommand;
class RoomResponse;
class RoomResponse_RoomInfo;
class GameCommand;
class GameResponse;
class GameResponse_GameSet;
class Command;
class Response;

enum AccountCommand_CommandType {
  AccountCommand_CommandType_REGISTER = 0,
  AccountCommand_CommandType_LOGIN = 1,
  AccountCommand_CommandType_EDIT = 2
};
bool AccountCommand_CommandType_IsValid(int value);
const AccountCommand_CommandType AccountCommand_CommandType_CommandType_MIN = AccountCommand_CommandType_REGISTER;
const AccountCommand_CommandType AccountCommand_CommandType_CommandType_MAX = AccountCommand_CommandType_EDIT;
const int AccountCommand_CommandType_CommandType_ARRAYSIZE = AccountCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountCommand_CommandType_descriptor();
inline const ::std::string& AccountCommand_CommandType_Name(AccountCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountCommand_CommandType_descriptor(), value);
}
inline bool AccountCommand_CommandType_Parse(
    const ::std::string& name, AccountCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountCommand_CommandType>(
    AccountCommand_CommandType_descriptor(), name, value);
}
enum AccountResponse_ResponseType {
  AccountResponse_ResponseType_SUCCESS = 0,
  AccountResponse_ResponseType_INVALID_USERNAME = 1,
  AccountResponse_ResponseType_INVALID_PASSWORD = 2,
  AccountResponse_ResponseType_INVALID_TOKEN = 3
};
bool AccountResponse_ResponseType_IsValid(int value);
const AccountResponse_ResponseType AccountResponse_ResponseType_ResponseType_MIN = AccountResponse_ResponseType_SUCCESS;
const AccountResponse_ResponseType AccountResponse_ResponseType_ResponseType_MAX = AccountResponse_ResponseType_INVALID_TOKEN;
const int AccountResponse_ResponseType_ResponseType_ARRAYSIZE = AccountResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* AccountResponse_ResponseType_descriptor();
inline const ::std::string& AccountResponse_ResponseType_Name(AccountResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    AccountResponse_ResponseType_descriptor(), value);
}
inline bool AccountResponse_ResponseType_Parse(
    const ::std::string& name, AccountResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<AccountResponse_ResponseType>(
    AccountResponse_ResponseType_descriptor(), name, value);
}
enum RoomCommand_CommandType {
  RoomCommand_CommandType_CREATE = 0,
  RoomCommand_CommandType_EDIT = 1,
  RoomCommand_CommandType_LIST = 2,
  RoomCommand_CommandType_ENTER = 3,
  RoomCommand_CommandType_LEAVE = 4
};
bool RoomCommand_CommandType_IsValid(int value);
const RoomCommand_CommandType RoomCommand_CommandType_CommandType_MIN = RoomCommand_CommandType_CREATE;
const RoomCommand_CommandType RoomCommand_CommandType_CommandType_MAX = RoomCommand_CommandType_LEAVE;
const int RoomCommand_CommandType_CommandType_ARRAYSIZE = RoomCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomCommand_CommandType_descriptor();
inline const ::std::string& RoomCommand_CommandType_Name(RoomCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomCommand_CommandType_descriptor(), value);
}
inline bool RoomCommand_CommandType_Parse(
    const ::std::string& name, RoomCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomCommand_CommandType>(
    RoomCommand_CommandType_descriptor(), name, value);
}
enum RoomResponse_ResponseType {
  RoomResponse_ResponseType_SUCCESS = 0,
  RoomResponse_ResponseType_INVALID_ROOM = 1
};
bool RoomResponse_ResponseType_IsValid(int value);
const RoomResponse_ResponseType RoomResponse_ResponseType_ResponseType_MIN = RoomResponse_ResponseType_SUCCESS;
const RoomResponse_ResponseType RoomResponse_ResponseType_ResponseType_MAX = RoomResponse_ResponseType_INVALID_ROOM;
const int RoomResponse_ResponseType_ResponseType_ARRAYSIZE = RoomResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RoomResponse_ResponseType_descriptor();
inline const ::std::string& RoomResponse_ResponseType_Name(RoomResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RoomResponse_ResponseType_descriptor(), value);
}
inline bool RoomResponse_ResponseType_Parse(
    const ::std::string& name, RoomResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RoomResponse_ResponseType>(
    RoomResponse_ResponseType_descriptor(), name, value);
}
enum GameCommand_CommandType {
  GameCommand_CommandType_ROOM = 0,
  GameCommand_CommandType_GAME = 1,
  GameCommand_CommandType_START = 2,
  GameCommand_CommandType_QUIT = 3
};
bool GameCommand_CommandType_IsValid(int value);
const GameCommand_CommandType GameCommand_CommandType_CommandType_MIN = GameCommand_CommandType_ROOM;
const GameCommand_CommandType GameCommand_CommandType_CommandType_MAX = GameCommand_CommandType_QUIT;
const int GameCommand_CommandType_CommandType_ARRAYSIZE = GameCommand_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameCommand_CommandType_descriptor();
inline const ::std::string& GameCommand_CommandType_Name(GameCommand_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameCommand_CommandType_descriptor(), value);
}
inline bool GameCommand_CommandType_Parse(
    const ::std::string& name, GameCommand_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameCommand_CommandType>(
    GameCommand_CommandType_descriptor(), name, value);
}
enum GameResponse_ResponseType {
  GameResponse_ResponseType_SUCCESS = 0,
  GameResponse_ResponseType_ERROR = 1,
  GameResponse_ResponseType_ROOM = 2,
  GameResponse_ResponseType_GAME = 3,
  GameResponse_ResponseType_OVER = 4
};
bool GameResponse_ResponseType_IsValid(int value);
const GameResponse_ResponseType GameResponse_ResponseType_ResponseType_MIN = GameResponse_ResponseType_SUCCESS;
const GameResponse_ResponseType GameResponse_ResponseType_ResponseType_MAX = GameResponse_ResponseType_OVER;
const int GameResponse_ResponseType_ResponseType_ARRAYSIZE = GameResponse_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GameResponse_ResponseType_descriptor();
inline const ::std::string& GameResponse_ResponseType_Name(GameResponse_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GameResponse_ResponseType_descriptor(), value);
}
inline bool GameResponse_ResponseType_Parse(
    const ::std::string& name, GameResponse_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GameResponse_ResponseType>(
    GameResponse_ResponseType_descriptor(), name, value);
}
enum Command_CommandType {
  Command_CommandType_ACCOUNT = 0,
  Command_CommandType_ROOM = 1,
  Command_CommandType_GAME = 2
};
bool Command_CommandType_IsValid(int value);
const Command_CommandType Command_CommandType_CommandType_MIN = Command_CommandType_ACCOUNT;
const Command_CommandType Command_CommandType_CommandType_MAX = Command_CommandType_GAME;
const int Command_CommandType_CommandType_ARRAYSIZE = Command_CommandType_CommandType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Command_CommandType_descriptor();
inline const ::std::string& Command_CommandType_Name(Command_CommandType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Command_CommandType_descriptor(), value);
}
inline bool Command_CommandType_Parse(
    const ::std::string& name, Command_CommandType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Command_CommandType>(
    Command_CommandType_descriptor(), name, value);
}
enum Response_ResponseType {
  Response_ResponseType_ACCOUNT = 0,
  Response_ResponseType_ROOM = 1,
  Response_ResponseType_GAME = 2
};
bool Response_ResponseType_IsValid(int value);
const Response_ResponseType Response_ResponseType_ResponseType_MIN = Response_ResponseType_ACCOUNT;
const Response_ResponseType Response_ResponseType_ResponseType_MAX = Response_ResponseType_GAME;
const int Response_ResponseType_ResponseType_ARRAYSIZE = Response_ResponseType_ResponseType_MAX + 1;

const ::google::protobuf::EnumDescriptor* Response_ResponseType_descriptor();
inline const ::std::string& Response_ResponseType_Name(Response_ResponseType value) {
  return ::google::protobuf::internal::NameOfEnum(
    Response_ResponseType_descriptor(), value);
}
inline bool Response_ResponseType_Parse(
    const ::std::string& name, Response_ResponseType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Response_ResponseType>(
    Response_ResponseType_descriptor(), name, value);
}
// ===================================================================

class AccountCommand : public ::google::protobuf::Message {
 public:
  AccountCommand();
  virtual ~AccountCommand();

  AccountCommand(const AccountCommand& from);

  inline AccountCommand& operator=(const AccountCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountCommand& default_instance();

  void Swap(AccountCommand* other);

  // implements Message ----------------------------------------------

  AccountCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountCommand& from);
  void MergeFrom(const AccountCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccountCommand_CommandType CommandType;
  static const CommandType REGISTER = AccountCommand_CommandType_REGISTER;
  static const CommandType LOGIN = AccountCommand_CommandType_LOGIN;
  static const CommandType EDIT = AccountCommand_CommandType_EDIT;
  static inline bool CommandType_IsValid(int value) {
    return AccountCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    AccountCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    AccountCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    AccountCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return AccountCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return AccountCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return AccountCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.AccountCommand.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::AccountCommand_CommandType type() const;
  inline void set_type(::tronol::protobuf::AccountCommand_CommandType value);

  // required string username = 2;
  inline bool has_username() const;
  inline void clear_username();
  static const int kUsernameFieldNumber = 2;
  inline const ::std::string& username() const;
  inline void set_username(const ::std::string& value);
  inline void set_username(const char* value);
  inline void set_username(const char* value, size_t size);
  inline ::std::string* mutable_username();
  inline ::std::string* release_username();
  inline void set_allocated_username(::std::string* username);

  // optional string password = 3;
  inline bool has_password() const;
  inline void clear_password();
  static const int kPasswordFieldNumber = 3;
  inline const ::std::string& password() const;
  inline void set_password(const ::std::string& value);
  inline void set_password(const char* value);
  inline void set_password(const char* value, size_t size);
  inline ::std::string* mutable_password();
  inline ::std::string* release_password();
  inline void set_allocated_password(::std::string* password);

  // optional string nickname = 4;
  inline bool has_nickname() const;
  inline void clear_nickname();
  static const int kNicknameFieldNumber = 4;
  inline const ::std::string& nickname() const;
  inline void set_nickname(const ::std::string& value);
  inline void set_nickname(const char* value);
  inline void set_nickname(const char* value, size_t size);
  inline ::std::string* mutable_nickname();
  inline ::std::string* release_nickname();
  inline void set_allocated_nickname(::std::string* nickname);

  // optional string token = 5;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 5;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.AccountCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_username();
  inline void clear_has_username();
  inline void set_has_password();
  inline void clear_has_password();
  inline void set_has_nickname();
  inline void clear_has_nickname();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* username_;
  ::std::string* password_;
  ::std::string* nickname_;
  ::std::string* token_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static AccountCommand* default_instance_;
};
// -------------------------------------------------------------------

class AccountResponse : public ::google::protobuf::Message {
 public:
  AccountResponse();
  virtual ~AccountResponse();

  AccountResponse(const AccountResponse& from);

  inline AccountResponse& operator=(const AccountResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AccountResponse& default_instance();

  void Swap(AccountResponse* other);

  // implements Message ----------------------------------------------

  AccountResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const AccountResponse& from);
  void MergeFrom(const AccountResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef AccountResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS = AccountResponse_ResponseType_SUCCESS;
  static const ResponseType INVALID_USERNAME = AccountResponse_ResponseType_INVALID_USERNAME;
  static const ResponseType INVALID_PASSWORD = AccountResponse_ResponseType_INVALID_PASSWORD;
  static const ResponseType INVALID_TOKEN = AccountResponse_ResponseType_INVALID_TOKEN;
  static inline bool ResponseType_IsValid(int value) {
    return AccountResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    AccountResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    AccountResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    AccountResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return AccountResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return AccountResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return AccountResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.AccountResponse.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::AccountResponse_ResponseType type() const;
  inline void set_type(::tronol::protobuf::AccountResponse_ResponseType value);

  // optional string token = 2;
  inline bool has_token() const;
  inline void clear_token();
  static const int kTokenFieldNumber = 2;
  inline const ::std::string& token() const;
  inline void set_token(const ::std::string& value);
  inline void set_token(const char* value);
  inline void set_token(const char* value, size_t size);
  inline ::std::string* mutable_token();
  inline ::std::string* release_token();
  inline void set_allocated_token(::std::string* token);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.AccountResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_token();
  inline void clear_has_token();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* token_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static AccountResponse* default_instance_;
};
// -------------------------------------------------------------------

class RoomCommand : public ::google::protobuf::Message {
 public:
  RoomCommand();
  virtual ~RoomCommand();

  RoomCommand(const RoomCommand& from);

  inline RoomCommand& operator=(const RoomCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomCommand& default_instance();

  void Swap(RoomCommand* other);

  // implements Message ----------------------------------------------

  RoomCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomCommand& from);
  void MergeFrom(const RoomCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomCommand_CommandType CommandType;
  static const CommandType CREATE = RoomCommand_CommandType_CREATE;
  static const CommandType EDIT = RoomCommand_CommandType_EDIT;
  static const CommandType LIST = RoomCommand_CommandType_LIST;
  static const CommandType ENTER = RoomCommand_CommandType_ENTER;
  static const CommandType LEAVE = RoomCommand_CommandType_LEAVE;
  static inline bool CommandType_IsValid(int value) {
    return RoomCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    RoomCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    RoomCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    RoomCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return RoomCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return RoomCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return RoomCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.RoomCommand.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::RoomCommand_CommandType type() const;
  inline void set_type(::tronol::protobuf::RoomCommand_CommandType value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // optional string name = 3;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 3;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 wins = 4;
  inline bool has_wins() const;
  inline void clear_wins();
  static const int kWinsFieldNumber = 4;
  inline ::google::protobuf::int32 wins() const;
  inline void set_wins(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_wins();
  inline void clear_has_wins();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::std::string* name_;
  ::google::protobuf::int32 wins_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static RoomCommand* default_instance_;
};
// -------------------------------------------------------------------

class RoomResponse_RoomInfo : public ::google::protobuf::Message {
 public:
  RoomResponse_RoomInfo();
  virtual ~RoomResponse_RoomInfo();

  RoomResponse_RoomInfo(const RoomResponse_RoomInfo& from);

  inline RoomResponse_RoomInfo& operator=(const RoomResponse_RoomInfo& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomResponse_RoomInfo& default_instance();

  void Swap(RoomResponse_RoomInfo* other);

  // implements Message ----------------------------------------------

  RoomResponse_RoomInfo* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomResponse_RoomInfo& from);
  void MergeFrom(const RoomResponse_RoomInfo& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 id = 1;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 1;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // required string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string host = 3;
  inline bool has_host() const;
  inline void clear_host();
  static const int kHostFieldNumber = 3;
  inline const ::std::string& host() const;
  inline void set_host(const ::std::string& value);
  inline void set_host(const char* value);
  inline void set_host(const char* value, size_t size);
  inline ::std::string* mutable_host();
  inline ::std::string* release_host();
  inline void set_allocated_host(::std::string* host);

  // optional string status = 4;
  inline bool has_status() const;
  inline void clear_status();
  static const int kStatusFieldNumber = 4;
  inline const ::std::string& status() const;
  inline void set_status(const ::std::string& value);
  inline void set_status(const char* value);
  inline void set_status(const char* value, size_t size);
  inline ::std::string* mutable_status();
  inline ::std::string* release_status();
  inline void set_allocated_status(::std::string* status);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomResponse.RoomInfo)
 private:
  inline void set_has_id();
  inline void clear_has_id();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_host();
  inline void clear_has_host();
  inline void set_has_status();
  inline void clear_has_status();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::std::string* name_;
  ::std::string* host_;
  ::std::string* status_;
  ::google::protobuf::int32 id_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static RoomResponse_RoomInfo* default_instance_;
};
// -------------------------------------------------------------------

class RoomResponse : public ::google::protobuf::Message {
 public:
  RoomResponse();
  virtual ~RoomResponse();

  RoomResponse(const RoomResponse& from);

  inline RoomResponse& operator=(const RoomResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RoomResponse& default_instance();

  void Swap(RoomResponse* other);

  // implements Message ----------------------------------------------

  RoomResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const RoomResponse& from);
  void MergeFrom(const RoomResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef RoomResponse_RoomInfo RoomInfo;

  typedef RoomResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS = RoomResponse_ResponseType_SUCCESS;
  static const ResponseType INVALID_ROOM = RoomResponse_ResponseType_INVALID_ROOM;
  static inline bool ResponseType_IsValid(int value) {
    return RoomResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    RoomResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    RoomResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    RoomResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return RoomResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return RoomResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return RoomResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.RoomResponse.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::RoomResponse_ResponseType type() const;
  inline void set_type(::tronol::protobuf::RoomResponse_ResponseType value);

  // optional int32 id = 2;
  inline bool has_id() const;
  inline void clear_id();
  static const int kIdFieldNumber = 2;
  inline ::google::protobuf::int32 id() const;
  inline void set_id(::google::protobuf::int32 value);

  // repeated .tronol.protobuf.RoomResponse.RoomInfo room = 3;
  inline int room_size() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline const ::tronol::protobuf::RoomResponse_RoomInfo& room(int index) const;
  inline ::tronol::protobuf::RoomResponse_RoomInfo* mutable_room(int index);
  inline ::tronol::protobuf::RoomResponse_RoomInfo* add_room();
  inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >&
      room() const;
  inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >*
      mutable_room();

  // @@protoc_insertion_point(class_scope:tronol.protobuf.RoomResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_id();
  inline void clear_has_id();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo > room_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static RoomResponse* default_instance_;
};
// -------------------------------------------------------------------

class GameCommand : public ::google::protobuf::Message {
 public:
  GameCommand();
  virtual ~GameCommand();

  GameCommand(const GameCommand& from);

  inline GameCommand& operator=(const GameCommand& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameCommand& default_instance();

  void Swap(GameCommand* other);

  // implements Message ----------------------------------------------

  GameCommand* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameCommand& from);
  void MergeFrom(const GameCommand& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameCommand_CommandType CommandType;
  static const CommandType ROOM = GameCommand_CommandType_ROOM;
  static const CommandType GAME = GameCommand_CommandType_GAME;
  static const CommandType START = GameCommand_CommandType_START;
  static const CommandType QUIT = GameCommand_CommandType_QUIT;
  static inline bool CommandType_IsValid(int value) {
    return GameCommand_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    GameCommand_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    GameCommand_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    GameCommand_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return GameCommand_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return GameCommand_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return GameCommand_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.GameCommand.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::GameCommand_CommandType type() const;
  inline void set_type(::tronol::protobuf::GameCommand_CommandType value);

  // optional int32 tick = 2;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 2;
  inline ::google::protobuf::int32 tick() const;
  inline void set_tick(::google::protobuf::int32 value);

  // repeated int32 dir = 3;
  inline int dir_size() const;
  inline void clear_dir();
  static const int kDirFieldNumber = 3;
  inline ::google::protobuf::int32 dir(int index) const;
  inline void set_dir(int index, ::google::protobuf::int32 value);
  inline void add_dir(::google::protobuf::int32 value);
  inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
      dir() const;
  inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
      mutable_dir();

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameCommand)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tick();
  inline void clear_has_tick();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  int type_;
  ::google::protobuf::int32 tick_;
  ::google::protobuf::RepeatedField< ::google::protobuf::int32 > dir_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static GameCommand* default_instance_;
};
// -------------------------------------------------------------------

class GameResponse_GameSet : public ::google::protobuf::Message {
 public:
  GameResponse_GameSet();
  virtual ~GameResponse_GameSet();

  GameResponse_GameSet(const GameResponse_GameSet& from);

  inline GameResponse_GameSet& operator=(const GameResponse_GameSet& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResponse_GameSet& default_instance();

  void Swap(GameResponse_GameSet* other);

  // implements Message ----------------------------------------------

  GameResponse_GameSet* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameResponse_GameSet& from);
  void MergeFrom(const GameResponse_GameSet& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required int32 x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline ::google::protobuf::int32 x() const;
  inline void set_x(::google::protobuf::int32 value);

  // required int32 y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline ::google::protobuf::int32 y() const;
  inline void set_y(::google::protobuf::int32 value);

  // required int32 v = 3;
  inline bool has_v() const;
  inline void clear_v();
  static const int kVFieldNumber = 3;
  inline ::google::protobuf::int32 v() const;
  inline void set_v(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameResponse.GameSet)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_v();
  inline void clear_has_v();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::int32 x_;
  ::google::protobuf::int32 y_;
  ::google::protobuf::int32 v_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static GameResponse_GameSet* default_instance_;
};
// -------------------------------------------------------------------

class GameResponse : public ::google::protobuf::Message {
 public:
  GameResponse();
  virtual ~GameResponse();

  GameResponse(const GameResponse& from);

  inline GameResponse& operator=(const GameResponse& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const GameResponse& default_instance();

  void Swap(GameResponse* other);

  // implements Message ----------------------------------------------

  GameResponse* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const GameResponse& from);
  void MergeFrom(const GameResponse& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef GameResponse_GameSet GameSet;

  typedef GameResponse_ResponseType ResponseType;
  static const ResponseType SUCCESS = GameResponse_ResponseType_SUCCESS;
  static const ResponseType ERROR = GameResponse_ResponseType_ERROR;
  static const ResponseType ROOM = GameResponse_ResponseType_ROOM;
  static const ResponseType GAME = GameResponse_ResponseType_GAME;
  static const ResponseType OVER = GameResponse_ResponseType_OVER;
  static inline bool ResponseType_IsValid(int value) {
    return GameResponse_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    GameResponse_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    GameResponse_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    GameResponse_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return GameResponse_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return GameResponse_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return GameResponse_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.GameResponse.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::GameResponse_ResponseType type() const;
  inline void set_type(::tronol::protobuf::GameResponse_ResponseType value);

  // repeated .tronol.protobuf.GameResponse.GameSet set_at = 2;
  inline int set_at_size() const;
  inline void clear_set_at();
  static const int kSetAtFieldNumber = 2;
  inline const ::tronol::protobuf::GameResponse_GameSet& set_at(int index) const;
  inline ::tronol::protobuf::GameResponse_GameSet* mutable_set_at(int index);
  inline ::tronol::protobuf::GameResponse_GameSet* add_set_at();
  inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >&
      set_at() const;
  inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >*
      mutable_set_at();

  // repeated string users = 3;
  inline int users_size() const;
  inline void clear_users();
  static const int kUsersFieldNumber = 3;
  inline const ::std::string& users(int index) const;
  inline ::std::string* mutable_users(int index);
  inline void set_users(int index, const ::std::string& value);
  inline void set_users(int index, const char* value);
  inline void set_users(int index, const char* value, size_t size);
  inline ::std::string* add_users();
  inline void add_users(const ::std::string& value);
  inline void add_users(const char* value);
  inline void add_users(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& users() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_users();

  // optional int32 tick = 4;
  inline bool has_tick() const;
  inline void clear_tick();
  static const int kTickFieldNumber = 4;
  inline ::google::protobuf::int32 tick() const;
  inline void set_tick(::google::protobuf::int32 value);

  // optional string winner = 5;
  inline bool has_winner() const;
  inline void clear_winner();
  static const int kWinnerFieldNumber = 5;
  inline const ::std::string& winner() const;
  inline void set_winner(const ::std::string& value);
  inline void set_winner(const char* value);
  inline void set_winner(const char* value, size_t size);
  inline ::std::string* mutable_winner();
  inline ::std::string* release_winner();
  inline void set_allocated_winner(::std::string* winner);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.GameResponse)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_tick();
  inline void clear_has_tick();
  inline void set_has_winner();
  inline void clear_has_winner();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet > set_at_;
  int type_;
  ::google::protobuf::int32 tick_;
  ::google::protobuf::RepeatedPtrField< ::std::string> users_;
  ::std::string* winner_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static GameResponse* default_instance_;
};
// -------------------------------------------------------------------

class Command : public ::google::protobuf::Message {
 public:
  Command();
  virtual ~Command();

  Command(const Command& from);

  inline Command& operator=(const Command& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Command& default_instance();

  void Swap(Command* other);

  // implements Message ----------------------------------------------

  Command* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Command& from);
  void MergeFrom(const Command& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Command_CommandType CommandType;
  static const CommandType ACCOUNT = Command_CommandType_ACCOUNT;
  static const CommandType ROOM = Command_CommandType_ROOM;
  static const CommandType GAME = Command_CommandType_GAME;
  static inline bool CommandType_IsValid(int value) {
    return Command_CommandType_IsValid(value);
  }
  static const CommandType CommandType_MIN =
    Command_CommandType_CommandType_MIN;
  static const CommandType CommandType_MAX =
    Command_CommandType_CommandType_MAX;
  static const int CommandType_ARRAYSIZE =
    Command_CommandType_CommandType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  CommandType_descriptor() {
    return Command_CommandType_descriptor();
  }
  static inline const ::std::string& CommandType_Name(CommandType value) {
    return Command_CommandType_Name(value);
  }
  static inline bool CommandType_Parse(const ::std::string& name,
      CommandType* value) {
    return Command_CommandType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.Command.CommandType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::Command_CommandType type() const;
  inline void set_type(::tronol::protobuf::Command_CommandType value);

  // optional .tronol.protobuf.AccountCommand account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::tronol::protobuf::AccountCommand& account() const;
  inline ::tronol::protobuf::AccountCommand* mutable_account();
  inline ::tronol::protobuf::AccountCommand* release_account();
  inline void set_allocated_account(::tronol::protobuf::AccountCommand* account);

  // optional .tronol.protobuf.RoomCommand room = 3;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline const ::tronol::protobuf::RoomCommand& room() const;
  inline ::tronol::protobuf::RoomCommand* mutable_room();
  inline ::tronol::protobuf::RoomCommand* release_room();
  inline void set_allocated_room(::tronol::protobuf::RoomCommand* room);

  // optional .tronol.protobuf.GameCommand game = 4;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 4;
  inline const ::tronol::protobuf::GameCommand& game() const;
  inline ::tronol::protobuf::GameCommand* mutable_game();
  inline ::tronol::protobuf::GameCommand* release_game();
  inline void set_allocated_game(::tronol::protobuf::GameCommand* game);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.Command)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_game();
  inline void clear_has_game();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tronol::protobuf::AccountCommand* account_;
  ::tronol::protobuf::RoomCommand* room_;
  ::tronol::protobuf::GameCommand* game_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static Command* default_instance_;
};
// -------------------------------------------------------------------

class Response : public ::google::protobuf::Message {
 public:
  Response();
  virtual ~Response();

  Response(const Response& from);

  inline Response& operator=(const Response& from) {
    CopyFrom(from);
    return *this;
  }

  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _unknown_fields_;
  }

  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return &_unknown_fields_;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Response& default_instance();

  void Swap(Response* other);

  // implements Message ----------------------------------------------

  Response* New() const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Response& from);
  void MergeFrom(const Response& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  typedef Response_ResponseType ResponseType;
  static const ResponseType ACCOUNT = Response_ResponseType_ACCOUNT;
  static const ResponseType ROOM = Response_ResponseType_ROOM;
  static const ResponseType GAME = Response_ResponseType_GAME;
  static inline bool ResponseType_IsValid(int value) {
    return Response_ResponseType_IsValid(value);
  }
  static const ResponseType ResponseType_MIN =
    Response_ResponseType_ResponseType_MIN;
  static const ResponseType ResponseType_MAX =
    Response_ResponseType_ResponseType_MAX;
  static const int ResponseType_ARRAYSIZE =
    Response_ResponseType_ResponseType_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  ResponseType_descriptor() {
    return Response_ResponseType_descriptor();
  }
  static inline const ::std::string& ResponseType_Name(ResponseType value) {
    return Response_ResponseType_Name(value);
  }
  static inline bool ResponseType_Parse(const ::std::string& name,
      ResponseType* value) {
    return Response_ResponseType_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // required .tronol.protobuf.Response.ResponseType type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::tronol::protobuf::Response_ResponseType type() const;
  inline void set_type(::tronol::protobuf::Response_ResponseType value);

  // optional .tronol.protobuf.AccountResponse account = 2;
  inline bool has_account() const;
  inline void clear_account();
  static const int kAccountFieldNumber = 2;
  inline const ::tronol::protobuf::AccountResponse& account() const;
  inline ::tronol::protobuf::AccountResponse* mutable_account();
  inline ::tronol::protobuf::AccountResponse* release_account();
  inline void set_allocated_account(::tronol::protobuf::AccountResponse* account);

  // optional .tronol.protobuf.RoomResponse room = 3;
  inline bool has_room() const;
  inline void clear_room();
  static const int kRoomFieldNumber = 3;
  inline const ::tronol::protobuf::RoomResponse& room() const;
  inline ::tronol::protobuf::RoomResponse* mutable_room();
  inline ::tronol::protobuf::RoomResponse* release_room();
  inline void set_allocated_room(::tronol::protobuf::RoomResponse* room);

  // optional .tronol.protobuf.GameResponse game = 4;
  inline bool has_game() const;
  inline void clear_game();
  static const int kGameFieldNumber = 4;
  inline const ::tronol::protobuf::GameResponse& game() const;
  inline ::tronol::protobuf::GameResponse* mutable_game();
  inline ::tronol::protobuf::GameResponse* release_game();
  inline void set_allocated_game(::tronol::protobuf::GameResponse* game);

  // @@protoc_insertion_point(class_scope:tronol.protobuf.Response)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_account();
  inline void clear_has_account();
  inline void set_has_room();
  inline void clear_has_room();
  inline void set_has_game();
  inline void clear_has_game();

  ::google::protobuf::UnknownFieldSet _unknown_fields_;

  ::tronol::protobuf::AccountResponse* account_;
  ::tronol::protobuf::RoomResponse* room_;
  ::tronol::protobuf::GameResponse* game_;
  int type_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  friend void  protobuf_AddDesc_tron_2eproto();
  friend void protobuf_AssignDesc_tron_2eproto();
  friend void protobuf_ShutdownFile_tron_2eproto();

  void InitAsDefaultInstance();
  static Response* default_instance_;
};
// ===================================================================


// ===================================================================

// AccountCommand

// required .tronol.protobuf.AccountCommand.CommandType type = 1;
inline bool AccountCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::AccountCommand_CommandType AccountCommand::type() const {
  return static_cast< ::tronol::protobuf::AccountCommand_CommandType >(type_);
}
inline void AccountCommand::set_type(::tronol::protobuf::AccountCommand_CommandType value) {
  assert(::tronol::protobuf::AccountCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// required string username = 2;
inline bool AccountCommand::has_username() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountCommand::set_has_username() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountCommand::clear_has_username() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountCommand::clear_username() {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    username_->clear();
  }
  clear_has_username();
}
inline const ::std::string& AccountCommand::username() const {
  return *username_;
}
inline void AccountCommand::set_username(const ::std::string& value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AccountCommand::set_username(const char* value) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(value);
}
inline void AccountCommand::set_username(const char* value, size_t size) {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  username_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountCommand::mutable_username() {
  set_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    username_ = new ::std::string;
  }
  return username_;
}
inline ::std::string* AccountCommand::release_username() {
  clear_has_username();
  if (username_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = username_;
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountCommand::set_allocated_username(::std::string* username) {
  if (username_ != &::google::protobuf::internal::kEmptyString) {
    delete username_;
  }
  if (username) {
    set_has_username();
    username_ = username;
  } else {
    clear_has_username();
    username_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string password = 3;
inline bool AccountCommand::has_password() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AccountCommand::set_has_password() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AccountCommand::clear_has_password() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AccountCommand::clear_password() {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    password_->clear();
  }
  clear_has_password();
}
inline const ::std::string& AccountCommand::password() const {
  return *password_;
}
inline void AccountCommand::set_password(const ::std::string& value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountCommand::set_password(const char* value) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(value);
}
inline void AccountCommand::set_password(const char* value, size_t size) {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  password_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountCommand::mutable_password() {
  set_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    password_ = new ::std::string;
  }
  return password_;
}
inline ::std::string* AccountCommand::release_password() {
  clear_has_password();
  if (password_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = password_;
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountCommand::set_allocated_password(::std::string* password) {
  if (password_ != &::google::protobuf::internal::kEmptyString) {
    delete password_;
  }
  if (password) {
    set_has_password();
    password_ = password;
  } else {
    clear_has_password();
    password_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string nickname = 4;
inline bool AccountCommand::has_nickname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AccountCommand::set_has_nickname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AccountCommand::clear_has_nickname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AccountCommand::clear_nickname() {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    nickname_->clear();
  }
  clear_has_nickname();
}
inline const ::std::string& AccountCommand::nickname() const {
  return *nickname_;
}
inline void AccountCommand::set_nickname(const ::std::string& value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void AccountCommand::set_nickname(const char* value) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(value);
}
inline void AccountCommand::set_nickname(const char* value, size_t size) {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  nickname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountCommand::mutable_nickname() {
  set_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    nickname_ = new ::std::string;
  }
  return nickname_;
}
inline ::std::string* AccountCommand::release_nickname() {
  clear_has_nickname();
  if (nickname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = nickname_;
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountCommand::set_allocated_nickname(::std::string* nickname) {
  if (nickname_ != &::google::protobuf::internal::kEmptyString) {
    delete nickname_;
  }
  if (nickname) {
    set_has_nickname();
    nickname_ = nickname;
  } else {
    clear_has_nickname();
    nickname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string token = 5;
inline bool AccountCommand::has_token() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AccountCommand::set_has_token() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AccountCommand::clear_has_token() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AccountCommand::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AccountCommand::token() const {
  return *token_;
}
inline void AccountCommand::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountCommand::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountCommand::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountCommand::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AccountCommand::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountCommand::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// AccountResponse

// required .tronol.protobuf.AccountResponse.ResponseType type = 1;
inline bool AccountResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AccountResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AccountResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AccountResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::AccountResponse_ResponseType AccountResponse::type() const {
  return static_cast< ::tronol::protobuf::AccountResponse_ResponseType >(type_);
}
inline void AccountResponse::set_type(::tronol::protobuf::AccountResponse_ResponseType value) {
  assert(::tronol::protobuf::AccountResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional string token = 2;
inline bool AccountResponse::has_token() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AccountResponse::set_has_token() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AccountResponse::clear_has_token() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AccountResponse::clear_token() {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    token_->clear();
  }
  clear_has_token();
}
inline const ::std::string& AccountResponse::token() const {
  return *token_;
}
inline void AccountResponse::set_token(const ::std::string& value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountResponse::set_token(const char* value) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(value);
}
inline void AccountResponse::set_token(const char* value, size_t size) {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  token_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* AccountResponse::mutable_token() {
  set_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    token_ = new ::std::string;
  }
  return token_;
}
inline ::std::string* AccountResponse::release_token() {
  clear_has_token();
  if (token_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = token_;
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void AccountResponse::set_allocated_token(::std::string* token) {
  if (token_ != &::google::protobuf::internal::kEmptyString) {
    delete token_;
  }
  if (token) {
    set_has_token();
    token_ = token;
  } else {
    clear_has_token();
    token_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomCommand

// required .tronol.protobuf.RoomCommand.CommandType type = 1;
inline bool RoomCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::RoomCommand_CommandType RoomCommand::type() const {
  return static_cast< ::tronol::protobuf::RoomCommand_CommandType >(type_);
}
inline void RoomCommand::set_type(::tronol::protobuf::RoomCommand_CommandType value) {
  assert(::tronol::protobuf::RoomCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool RoomCommand::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomCommand::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomCommand::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomCommand::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomCommand::id() const {
  return id_;
}
inline void RoomCommand::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// optional string name = 3;
inline bool RoomCommand::has_name() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomCommand::set_has_name() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomCommand::clear_has_name() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomCommand::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomCommand::name() const {
  return *name_;
}
inline void RoomCommand::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomCommand::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomCommand::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomCommand::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoomCommand::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomCommand::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 wins = 4;
inline bool RoomCommand::has_wins() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomCommand::set_has_wins() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomCommand::clear_has_wins() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomCommand::clear_wins() {
  wins_ = 0;
  clear_has_wins();
}
inline ::google::protobuf::int32 RoomCommand::wins() const {
  return wins_;
}
inline void RoomCommand::set_wins(::google::protobuf::int32 value) {
  set_has_wins();
  wins_ = value;
}

// -------------------------------------------------------------------

// RoomResponse_RoomInfo

// required int32 id = 1;
inline bool RoomResponse_RoomInfo::has_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomResponse_RoomInfo::clear_has_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomResponse_RoomInfo::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomResponse_RoomInfo::id() const {
  return id_;
}
inline void RoomResponse_RoomInfo::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// required string name = 2;
inline bool RoomResponse_RoomInfo::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomResponse_RoomInfo::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomResponse_RoomInfo::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& RoomResponse_RoomInfo::name() const {
  return *name_;
}
inline void RoomResponse_RoomInfo::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomResponse_RoomInfo::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void RoomResponse_RoomInfo::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomResponse_RoomInfo::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* RoomResponse_RoomInfo::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomResponse_RoomInfo::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string host = 3;
inline bool RoomResponse_RoomInfo::has_host() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_host() {
  _has_bits_[0] |= 0x00000004u;
}
inline void RoomResponse_RoomInfo::clear_has_host() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void RoomResponse_RoomInfo::clear_host() {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    host_->clear();
  }
  clear_has_host();
}
inline const ::std::string& RoomResponse_RoomInfo::host() const {
  return *host_;
}
inline void RoomResponse_RoomInfo::set_host(const ::std::string& value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void RoomResponse_RoomInfo::set_host(const char* value) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(value);
}
inline void RoomResponse_RoomInfo::set_host(const char* value, size_t size) {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  host_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomResponse_RoomInfo::mutable_host() {
  set_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    host_ = new ::std::string;
  }
  return host_;
}
inline ::std::string* RoomResponse_RoomInfo::release_host() {
  clear_has_host();
  if (host_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = host_;
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomResponse_RoomInfo::set_allocated_host(::std::string* host) {
  if (host_ != &::google::protobuf::internal::kEmptyString) {
    delete host_;
  }
  if (host) {
    set_has_host();
    host_ = host;
  } else {
    clear_has_host();
    host_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string status = 4;
inline bool RoomResponse_RoomInfo::has_status() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void RoomResponse_RoomInfo::set_has_status() {
  _has_bits_[0] |= 0x00000008u;
}
inline void RoomResponse_RoomInfo::clear_has_status() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void RoomResponse_RoomInfo::clear_status() {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    status_->clear();
  }
  clear_has_status();
}
inline const ::std::string& RoomResponse_RoomInfo::status() const {
  return *status_;
}
inline void RoomResponse_RoomInfo::set_status(const ::std::string& value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void RoomResponse_RoomInfo::set_status(const char* value) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(value);
}
inline void RoomResponse_RoomInfo::set_status(const char* value, size_t size) {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  status_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* RoomResponse_RoomInfo::mutable_status() {
  set_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    status_ = new ::std::string;
  }
  return status_;
}
inline ::std::string* RoomResponse_RoomInfo::release_status() {
  clear_has_status();
  if (status_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = status_;
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void RoomResponse_RoomInfo::set_allocated_status(::std::string* status) {
  if (status_ != &::google::protobuf::internal::kEmptyString) {
    delete status_;
  }
  if (status) {
    set_has_status();
    status_ = status;
  } else {
    clear_has_status();
    status_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// RoomResponse

// required .tronol.protobuf.RoomResponse.ResponseType type = 1;
inline bool RoomResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RoomResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RoomResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void RoomResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::RoomResponse_ResponseType RoomResponse::type() const {
  return static_cast< ::tronol::protobuf::RoomResponse_ResponseType >(type_);
}
inline void RoomResponse::set_type(::tronol::protobuf::RoomResponse_ResponseType value) {
  assert(::tronol::protobuf::RoomResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 id = 2;
inline bool RoomResponse::has_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void RoomResponse::set_has_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void RoomResponse::clear_has_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void RoomResponse::clear_id() {
  id_ = 0;
  clear_has_id();
}
inline ::google::protobuf::int32 RoomResponse::id() const {
  return id_;
}
inline void RoomResponse::set_id(::google::protobuf::int32 value) {
  set_has_id();
  id_ = value;
}

// repeated .tronol.protobuf.RoomResponse.RoomInfo room = 3;
inline int RoomResponse::room_size() const {
  return room_.size();
}
inline void RoomResponse::clear_room() {
  room_.Clear();
}
inline const ::tronol::protobuf::RoomResponse_RoomInfo& RoomResponse::room(int index) const {
  return room_.Get(index);
}
inline ::tronol::protobuf::RoomResponse_RoomInfo* RoomResponse::mutable_room(int index) {
  return room_.Mutable(index);
}
inline ::tronol::protobuf::RoomResponse_RoomInfo* RoomResponse::add_room() {
  return room_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >&
RoomResponse::room() const {
  return room_;
}
inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::RoomResponse_RoomInfo >*
RoomResponse::mutable_room() {
  return &room_;
}

// -------------------------------------------------------------------

// GameCommand

// required .tronol.protobuf.GameCommand.CommandType type = 1;
inline bool GameCommand::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameCommand::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameCommand::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameCommand::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::GameCommand_CommandType GameCommand::type() const {
  return static_cast< ::tronol::protobuf::GameCommand_CommandType >(type_);
}
inline void GameCommand::set_type(::tronol::protobuf::GameCommand_CommandType value) {
  assert(::tronol::protobuf::GameCommand_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional int32 tick = 2;
inline bool GameCommand::has_tick() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameCommand::set_has_tick() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameCommand::clear_has_tick() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameCommand::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
inline ::google::protobuf::int32 GameCommand::tick() const {
  return tick_;
}
inline void GameCommand::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
}

// repeated int32 dir = 3;
inline int GameCommand::dir_size() const {
  return dir_.size();
}
inline void GameCommand::clear_dir() {
  dir_.Clear();
}
inline ::google::protobuf::int32 GameCommand::dir(int index) const {
  return dir_.Get(index);
}
inline void GameCommand::set_dir(int index, ::google::protobuf::int32 value) {
  dir_.Set(index, value);
}
inline void GameCommand::add_dir(::google::protobuf::int32 value) {
  dir_.Add(value);
}
inline const ::google::protobuf::RepeatedField< ::google::protobuf::int32 >&
GameCommand::dir() const {
  return dir_;
}
inline ::google::protobuf::RepeatedField< ::google::protobuf::int32 >*
GameCommand::mutable_dir() {
  return &dir_;
}

// -------------------------------------------------------------------

// GameResponse_GameSet

// required int32 x = 1;
inline bool GameResponse_GameSet::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResponse_GameSet::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResponse_GameSet::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResponse_GameSet::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline ::google::protobuf::int32 GameResponse_GameSet::x() const {
  return x_;
}
inline void GameResponse_GameSet::set_x(::google::protobuf::int32 value) {
  set_has_x();
  x_ = value;
}

// required int32 y = 2;
inline bool GameResponse_GameSet::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void GameResponse_GameSet::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void GameResponse_GameSet::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void GameResponse_GameSet::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline ::google::protobuf::int32 GameResponse_GameSet::y() const {
  return y_;
}
inline void GameResponse_GameSet::set_y(::google::protobuf::int32 value) {
  set_has_y();
  y_ = value;
}

// required int32 v = 3;
inline bool GameResponse_GameSet::has_v() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void GameResponse_GameSet::set_has_v() {
  _has_bits_[0] |= 0x00000004u;
}
inline void GameResponse_GameSet::clear_has_v() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void GameResponse_GameSet::clear_v() {
  v_ = 0;
  clear_has_v();
}
inline ::google::protobuf::int32 GameResponse_GameSet::v() const {
  return v_;
}
inline void GameResponse_GameSet::set_v(::google::protobuf::int32 value) {
  set_has_v();
  v_ = value;
}

// -------------------------------------------------------------------

// GameResponse

// required .tronol.protobuf.GameResponse.ResponseType type = 1;
inline bool GameResponse::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void GameResponse::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void GameResponse::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void GameResponse::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::GameResponse_ResponseType GameResponse::type() const {
  return static_cast< ::tronol::protobuf::GameResponse_ResponseType >(type_);
}
inline void GameResponse::set_type(::tronol::protobuf::GameResponse_ResponseType value) {
  assert(::tronol::protobuf::GameResponse_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// repeated .tronol.protobuf.GameResponse.GameSet set_at = 2;
inline int GameResponse::set_at_size() const {
  return set_at_.size();
}
inline void GameResponse::clear_set_at() {
  set_at_.Clear();
}
inline const ::tronol::protobuf::GameResponse_GameSet& GameResponse::set_at(int index) const {
  return set_at_.Get(index);
}
inline ::tronol::protobuf::GameResponse_GameSet* GameResponse::mutable_set_at(int index) {
  return set_at_.Mutable(index);
}
inline ::tronol::protobuf::GameResponse_GameSet* GameResponse::add_set_at() {
  return set_at_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >&
GameResponse::set_at() const {
  return set_at_;
}
inline ::google::protobuf::RepeatedPtrField< ::tronol::protobuf::GameResponse_GameSet >*
GameResponse::mutable_set_at() {
  return &set_at_;
}

// repeated string users = 3;
inline int GameResponse::users_size() const {
  return users_.size();
}
inline void GameResponse::clear_users() {
  users_.Clear();
}
inline const ::std::string& GameResponse::users(int index) const {
  return users_.Get(index);
}
inline ::std::string* GameResponse::mutable_users(int index) {
  return users_.Mutable(index);
}
inline void GameResponse::set_users(int index, const ::std::string& value) {
  users_.Mutable(index)->assign(value);
}
inline void GameResponse::set_users(int index, const char* value) {
  users_.Mutable(index)->assign(value);
}
inline void GameResponse::set_users(int index, const char* value, size_t size) {
  users_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResponse::add_users() {
  return users_.Add();
}
inline void GameResponse::add_users(const ::std::string& value) {
  users_.Add()->assign(value);
}
inline void GameResponse::add_users(const char* value) {
  users_.Add()->assign(value);
}
inline void GameResponse::add_users(const char* value, size_t size) {
  users_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
GameResponse::users() const {
  return users_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
GameResponse::mutable_users() {
  return &users_;
}

// optional int32 tick = 4;
inline bool GameResponse::has_tick() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void GameResponse::set_has_tick() {
  _has_bits_[0] |= 0x00000008u;
}
inline void GameResponse::clear_has_tick() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void GameResponse::clear_tick() {
  tick_ = 0;
  clear_has_tick();
}
inline ::google::protobuf::int32 GameResponse::tick() const {
  return tick_;
}
inline void GameResponse::set_tick(::google::protobuf::int32 value) {
  set_has_tick();
  tick_ = value;
}

// optional string winner = 5;
inline bool GameResponse::has_winner() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void GameResponse::set_has_winner() {
  _has_bits_[0] |= 0x00000010u;
}
inline void GameResponse::clear_has_winner() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void GameResponse::clear_winner() {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    winner_->clear();
  }
  clear_has_winner();
}
inline const ::std::string& GameResponse::winner() const {
  return *winner_;
}
inline void GameResponse::set_winner(const ::std::string& value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void GameResponse::set_winner(const char* value) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(value);
}
inline void GameResponse::set_winner(const char* value, size_t size) {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  winner_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* GameResponse::mutable_winner() {
  set_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    winner_ = new ::std::string;
  }
  return winner_;
}
inline ::std::string* GameResponse::release_winner() {
  clear_has_winner();
  if (winner_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = winner_;
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void GameResponse::set_allocated_winner(::std::string* winner) {
  if (winner_ != &::google::protobuf::internal::kEmptyString) {
    delete winner_;
  }
  if (winner) {
    set_has_winner();
    winner_ = winner;
  } else {
    clear_has_winner();
    winner_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// Command

// required .tronol.protobuf.Command.CommandType type = 1;
inline bool Command::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Command::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Command::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Command::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::Command_CommandType Command::type() const {
  return static_cast< ::tronol::protobuf::Command_CommandType >(type_);
}
inline void Command::set_type(::tronol::protobuf::Command_CommandType value) {
  assert(::tronol::protobuf::Command_CommandType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .tronol.protobuf.AccountCommand account = 2;
inline bool Command::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Command::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Command::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Command::clear_account() {
  if (account_ != NULL) account_->::tronol::protobuf::AccountCommand::Clear();
  clear_has_account();
}
inline const ::tronol::protobuf::AccountCommand& Command::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::tronol::protobuf::AccountCommand* Command::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::tronol::protobuf::AccountCommand;
  return account_;
}
inline ::tronol::protobuf::AccountCommand* Command::release_account() {
  clear_has_account();
  ::tronol::protobuf::AccountCommand* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Command::set_allocated_account(::tronol::protobuf::AccountCommand* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// optional .tronol.protobuf.RoomCommand room = 3;
inline bool Command::has_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Command::set_has_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Command::clear_has_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Command::clear_room() {
  if (room_ != NULL) room_->::tronol::protobuf::RoomCommand::Clear();
  clear_has_room();
}
inline const ::tronol::protobuf::RoomCommand& Command::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::tronol::protobuf::RoomCommand* Command::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::tronol::protobuf::RoomCommand;
  return room_;
}
inline ::tronol::protobuf::RoomCommand* Command::release_room() {
  clear_has_room();
  ::tronol::protobuf::RoomCommand* temp = room_;
  room_ = NULL;
  return temp;
}
inline void Command::set_allocated_room(::tronol::protobuf::RoomCommand* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// optional .tronol.protobuf.GameCommand game = 4;
inline bool Command::has_game() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Command::set_has_game() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Command::clear_has_game() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Command::clear_game() {
  if (game_ != NULL) game_->::tronol::protobuf::GameCommand::Clear();
  clear_has_game();
}
inline const ::tronol::protobuf::GameCommand& Command::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::tronol::protobuf::GameCommand* Command::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::tronol::protobuf::GameCommand;
  return game_;
}
inline ::tronol::protobuf::GameCommand* Command::release_game() {
  clear_has_game();
  ::tronol::protobuf::GameCommand* temp = game_;
  game_ = NULL;
  return temp;
}
inline void Command::set_allocated_game(::tronol::protobuf::GameCommand* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}

// -------------------------------------------------------------------

// Response

// required .tronol.protobuf.Response.ResponseType type = 1;
inline bool Response::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Response::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Response::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Response::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::tronol::protobuf::Response_ResponseType Response::type() const {
  return static_cast< ::tronol::protobuf::Response_ResponseType >(type_);
}
inline void Response::set_type(::tronol::protobuf::Response_ResponseType value) {
  assert(::tronol::protobuf::Response_ResponseType_IsValid(value));
  set_has_type();
  type_ = value;
}

// optional .tronol.protobuf.AccountResponse account = 2;
inline bool Response::has_account() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Response::set_has_account() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Response::clear_has_account() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Response::clear_account() {
  if (account_ != NULL) account_->::tronol::protobuf::AccountResponse::Clear();
  clear_has_account();
}
inline const ::tronol::protobuf::AccountResponse& Response::account() const {
  return account_ != NULL ? *account_ : *default_instance_->account_;
}
inline ::tronol::protobuf::AccountResponse* Response::mutable_account() {
  set_has_account();
  if (account_ == NULL) account_ = new ::tronol::protobuf::AccountResponse;
  return account_;
}
inline ::tronol::protobuf::AccountResponse* Response::release_account() {
  clear_has_account();
  ::tronol::protobuf::AccountResponse* temp = account_;
  account_ = NULL;
  return temp;
}
inline void Response::set_allocated_account(::tronol::protobuf::AccountResponse* account) {
  delete account_;
  account_ = account;
  if (account) {
    set_has_account();
  } else {
    clear_has_account();
  }
}

// optional .tronol.protobuf.RoomResponse room = 3;
inline bool Response::has_room() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Response::set_has_room() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Response::clear_has_room() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Response::clear_room() {
  if (room_ != NULL) room_->::tronol::protobuf::RoomResponse::Clear();
  clear_has_room();
}
inline const ::tronol::protobuf::RoomResponse& Response::room() const {
  return room_ != NULL ? *room_ : *default_instance_->room_;
}
inline ::tronol::protobuf::RoomResponse* Response::mutable_room() {
  set_has_room();
  if (room_ == NULL) room_ = new ::tronol::protobuf::RoomResponse;
  return room_;
}
inline ::tronol::protobuf::RoomResponse* Response::release_room() {
  clear_has_room();
  ::tronol::protobuf::RoomResponse* temp = room_;
  room_ = NULL;
  return temp;
}
inline void Response::set_allocated_room(::tronol::protobuf::RoomResponse* room) {
  delete room_;
  room_ = room;
  if (room) {
    set_has_room();
  } else {
    clear_has_room();
  }
}

// optional .tronol.protobuf.GameResponse game = 4;
inline bool Response::has_game() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Response::set_has_game() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Response::clear_has_game() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Response::clear_game() {
  if (game_ != NULL) game_->::tronol::protobuf::GameResponse::Clear();
  clear_has_game();
}
inline const ::tronol::protobuf::GameResponse& Response::game() const {
  return game_ != NULL ? *game_ : *default_instance_->game_;
}
inline ::tronol::protobuf::GameResponse* Response::mutable_game() {
  set_has_game();
  if (game_ == NULL) game_ = new ::tronol::protobuf::GameResponse;
  return game_;
}
inline ::tronol::protobuf::GameResponse* Response::release_game() {
  clear_has_game();
  ::tronol::protobuf::GameResponse* temp = game_;
  game_ = NULL;
  return temp;
}
inline void Response::set_allocated_game(::tronol::protobuf::GameResponse* game) {
  delete game_;
  game_ = game;
  if (game) {
    set_has_game();
  } else {
    clear_has_game();
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protobuf
}  // namespace tronol

#ifndef SWIG
namespace google {
namespace protobuf {

template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::AccountCommand_CommandType>() {
  return ::tronol::protobuf::AccountCommand_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::AccountResponse_ResponseType>() {
  return ::tronol::protobuf::AccountResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::RoomCommand_CommandType>() {
  return ::tronol::protobuf::RoomCommand_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::RoomResponse_ResponseType>() {
  return ::tronol::protobuf::RoomResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::GameCommand_CommandType>() {
  return ::tronol::protobuf::GameCommand_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::GameResponse_ResponseType>() {
  return ::tronol::protobuf::GameResponse_ResponseType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::Command_CommandType>() {
  return ::tronol::protobuf::Command_CommandType_descriptor();
}
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::tronol::protobuf::Response_ResponseType>() {
  return ::tronol::protobuf::Response_ResponseType_descriptor();
}

}  // namespace google
}  // namespace protobuf
#endif  // SWIG

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_tron_2eproto__INCLUDED
